name: Claude PR Review

on:
  # Direct trigger for PRs in this (.github) repository
  issue_comment:
    types: [created]

  # Reusable workflow trigger for other repositories in the organization
  workflow_call:
    secrets:
      ANTHROPIC_API_KEY:
        required: true
        description: Anthropic API key for Claude API access
      LINEAR_API_KEY:
        required: false
        description: Linear API key for issue context retrieval
      CLAUDE_APP_PRIVATE_KEY:
        required: false
        description: GitHub App private key for posting reviews as Claude[bot]

# Note: Concurrency control is handled by the caller workflow

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  claude-review:
    # Run on workflow_call (caller already filtered) or direct PR comments from humans
    if: |
      github.event_name == 'workflow_call' ||
      (github.event.issue.pull_request &&
       contains(github.event.comment.body, '@claude') &&
       github.event.comment.user.type != 'Bot')

    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Validate commenter permissions
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            const commenter = context.payload.comment.user.login;
            const repo = context.repo;

            // Try org membership first
            try {
              await github.rest.orgs.checkMembershipForUser({
                org: repo.owner,
                username: commenter,
              });
              console.log(`‚úì ${commenter} is organization member`);
              return true;
            } catch (orgError) {
              // Check if repo collaborator with write access
              try {
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: repo.owner,
                  repo: repo.repo,
                  username: commenter,
                });
                if (['write', 'admin', 'maintain'].includes(permission.permission)) {
                  console.log(`‚úì ${commenter} is collaborator with ${permission.permission} access`);
                  return true;
                }
              } catch (e) {}
              console.log(`‚úó ${commenter} does not have sufficient permissions`);
              return false;
            }

      - name: Post permission denied
        if: steps.validate.outputs.result == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '‚ö†Ô∏è Claude reviews are only available to organization members and repository collaborators with write access.'
            });

      - name: Exit if permission denied
        if: steps.validate.outputs.result == 'false'
        run: exit 0

      - name: Generate GitHub App token
        id: app-token
        if: vars.CLAUDE_APP_ID != ''
        uses: actions/create-github-app-token@v2
        continue-on-error: true
        with:
          app-id: ${{ vars.CLAUDE_APP_ID }}
          private-key: ${{ secrets.CLAUDE_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Checkout .github repository for review standards
        uses: actions/checkout@v4
        with:
          repository: quantivly/.github
          path: .github-org
          sparse-checkout: |
            docs/review-standards.md
          fetch-depth: 1

      - name: Extract Linear issue ID
        id: linear
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            const match = pr.title.match(/^([A-Z]+-\d+)/);
            core.setOutput('linear_id', match ? match[1] : '');
            console.log(match ? `Linear issue: ${match[1]}` : 'No Linear issue ID in PR title');

      - name: Extract custom instructions
        id: instructions
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.comment.body;
            const match = body.match(/@claude\b[,:]?\s*(.*)/is);
            if (!match) {
              core.setOutput('custom', '');
              return;
            }
            let instructions = match[1].trim();
            const generic = ['', 'review', 'please review', 'review this', 'please review this', 'review this pr', 'please review this pr'];
            if (generic.includes(instructions.toLowerCase())) {
              core.setOutput('custom', '');
              return;
            }
            // Truncate to prevent prompt stuffing
            if (instructions.length > 2000) {
              instructions = instructions.substring(0, 2000) + '... (truncated)';
            }
            core.setOutput('custom', instructions);

      - name: Fetch previous review context
        id: previous-reviews
        uses: actions/github-script@v7
        env:
          APP_SLUG: ${{ steps.app-token.outputs.app-slug }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const repo = context.repo;

            // Derive bot login from the GitHub App slug (e.g. "quantivly-reviews" ‚Üí "quantivly-reviews[bot]")
            // Falls back to github-actions[bot] when no App token is available
            const appSlug = process.env.APP_SLUG;
            const botLogin = appSlug ? `${appSlug}[bot]` : 'github-actions[bot]';
            console.log(`Looking for reviews by: ${botLogin}`);

            // Fetch all reviews on this PR
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            // Identify Claude reviews by bot identity
            const claudeReviews = reviews.filter(r => r.user.login === botLogin);

            if (claudeReviews.length === 0) {
              core.setOutput('context', '');
              core.setOutput('count', '0');
              console.log('No previous Claude reviews found');
              return;
            }

            const reviewCount = claudeReviews.length;
            // Find the latest review with a meaningful body for the summary
            // (some reviews are inline-comment-only with empty bodies)
            const latest = claudeReviews.filter(r => (r.body || '').length > 0).pop()
              || claudeReviews[claudeReviews.length - 1];

            // Extract body summary: strip the <sub> footer and cap length
            let bodySummary = (latest.body || '').replace(/<sub>[\s\S]*?<\/sub>/g, '').trim();
            if (bodySummary.length > 800) {
              bodySummary = bodySummary.substring(0, 800) + '...';
            }

            // Fetch inline comments for the latest review
            const { data: allComments } = await github.rest.pulls.listReviewComments({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const reviewComments = allComments
              .filter(c => c.pull_request_review_id === latest.id)
              .map(c => {
                const firstSentence = (c.body || '').split(/[.\n]/)[0].trim();
                const entry = `- \`${c.path}:${c.line || c.original_line || '?'}\` ${firstSentence}`;
                return entry.length > 120 ? entry.substring(0, 117) + '...' : entry;
              });

            // Build context string
            const date = new Date(latest.submitted_at).toISOString().split('T')[0];
            let contextStr = `Previous Claude reviews: ${reviewCount}\n`;
            contextStr += `Latest review: ${date} (${latest.state})\n\n`;
            contextStr += `### Latest Review Summary\n${bodySummary}\n`;

            if (reviewComments.length > 0) {
              contextStr += `\n### Latest Review Inline Findings (${reviewComments.length})\n`;
              contextStr += reviewComments.join('\n');
            }

            // Hard cap at 4000 chars to control token budget
            if (contextStr.length > 4000) {
              contextStr = contextStr.substring(0, 3997) + '...';
            }

            core.setOutput('context', contextStr);
            core.setOutput('count', String(reviewCount));
            console.log(`Found ${reviewCount} previous Claude review(s). Context: ${contextStr.length} chars`);

      - name: Create MCP config for Linear
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
        run: |
          # Create .mcp.json with explicit auth headers for Linear MCP server
          # GitHub Actions needs explicit Bearer auth in .mcp.json
          # (locally, Claude Code auto-injects auth from env vars)
          if [ -n "$LINEAR_API_KEY" ]; then
            printf '{"mcpServers":{"linear":{"type":"http","url":"https://mcp.linear.app/mcp","headers":{"Authorization":"Bearer %s"}}}}' "$LINEAR_API_KEY" > .mcp.json
            echo "Created .mcp.json with Linear MCP server auth configuration"
          else
            echo "LINEAR_API_KEY not set, skipping MCP config"
          fi

      - name: Post progress comment
        id: progress
        if: steps.validate.outputs.result != 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: 'ü§ñ **Claude review started...** This typically takes 2-5 minutes.\n\n_Analyzing code for security, logic errors, code quality, testing, and performance._'
            });
            core.setOutput('comment_id', comment.id);
            console.log(`Posted progress comment ${comment.id}`);

      - name: Run Claude PR Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        env:
          # Linear MCP server (via .mcp.json) uses env var for API authentication
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          # gh CLI reads from GH_TOKEN env var (using GH_ prefix since GitHub reserves GITHUB_)
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          # Enable MCP servers from .mcp.json (provides Linear MCP auth config)
          settings: '{"enableAllProjectMcpServers": true}'
          # Allow tools for PR review:
          # - Linear MCP tools (issue context, requirements) via .mcp.json server
          # - gh CLI for: reading PR data, cross-repo files, submitting batched review, progress updates
          # - File tools for reading codebase
          # - git for commit history context
          # Review submission uses gh api POST to /reviews with comments array (single review event)
          claude_args: |
            --allowedTools "mcp__linear__*,Bash(gh pr:*),Bash(gh api:*),Bash(git log:*),Bash(git show:*),Bash(git diff:*),Read,Glob,Grep,LS"
          prompt: |
            REPO: ${{ github.repository }}
            PR NUMBER: ${{ github.event.issue.number }}
            LINEAR ISSUE: ${{ steps.linear.outputs.linear_id || 'Not specified' }}
            CUSTOM FOCUS: ${{ steps.instructions.outputs.custom || 'None - standard review' }}
            PROGRESS_COMMENT_ID: ${{ steps.progress.outputs.comment_id }}
            PREVIOUS_REVIEW_CONTEXT: ${{ steps.previous-reviews.outputs.context || 'None - this is the first review' }}
            PREVIOUS_REVIEW_COUNT: ${{ steps.previous-reviews.outputs.count || '0' }}

            ## Previous Review Context

            ${{ steps.previous-reviews.outputs.context || 'None - this is the first review.' }}

            ## Your Role

            You are an expert code reviewer for Quantivly, a healthcare technology company building HIPAA-compliant analytics software.

            ## Review Workflow (Single Submission)

            Your review is submitted as ONE gh api call ‚Äî both the summary and all inline comments in a single request.

            ```
            Step 1: ANALYZE ‚Äî Read standards, diff, Linear context, collect findings
            Step 2: SUBMIT ‚Äî One gh api call with summary + inline comments array
            ```

            **WRONG**: Posting individual comments one at a time (creates separate review events per comment)
            **RIGHT**: Collect ALL findings, then submit everything in one batched API call

            ---

            **Step 1: Analyze**

            1. Read `.github-org/docs/review-standards.md` and the repo's `CLAUDE.md`
            2. Run `gh pr diff $PR_NUMBER` to get the unified diff
            3. Check the PREVIOUS REVIEW CONTEXT above. If previous reviews exist:
               - Note which files/lines had prior findings
               - Compare against the current diff to determine if prior findings are on unchanged vs. changed code
               - Prior findings on unchanged code should NOT be re-flagged as inline comments (they are already visible in the PR conversation)
               - Focus inline comments on: (a) new code not previously reviewed, (b) code changed since the last review, (c) prior findings addressed incorrectly or incompletely
            4. Analyze the diff for security, logic, quality, testing, performance issues. Before flagging any issue, use `Read` to see the full file context around the location ‚Äî do not flag issues based solely on diff snippets.
            5. If Linear issue provided, fetch requirements and validate alignment
            6. For each finding, note: file path, line number (from the new version of the file), severity, description

            ---

            **Step 2: Submit Review (Single API Call)**

            Submit ALL findings in one call using this exact structure:

            ```
            gh api -X POST "repos/{REPO}/pulls/{PR_NUMBER}/reviews" --input - <<'REVIEW_JSON'
            {
              "event": "<EVENT>",
              "body": "<REVIEW_SUMMARY>",
              "comments": [
                {
                  "path": "src/auth/login.py",
                  "line": 42,
                  "side": "RIGHT",
                  "body": "‚ö†Ô∏è This endpoint accepts user input without validation, which could allow malformed data into the database"
                }
              ]
            }
            REVIEW_JSON
            ```

            Substitute the actual REPO and PR_NUMBER values from the context variables above.

            Rules for the JSON:
            - `line` is the line number in the new file version (integer)
            - `path` is relative to repo root (e.g., "src/auth/login.py")
            - `body` values must be valid JSON strings: escape `"` as `\"`, newlines as `\n`, backslashes as `\\`
            - `side` is always `"RIGHT"` for commenting on added/modified code
            - General observations that don't apply to a specific line go in the review `body`, not in `comments`

            Choose event based on findings:
            - `REQUEST_CHANGES`: Has CRITICAL issues
            - `COMMENT`: Has HIGH issues or needs clarification
            - `APPROVE`: Only suggestions, no blockers

            ---

            **If the review submission fails (e.g., 422 from invalid line number):**

            Retry without the `comments` array ‚Äî put all findings in the body as formatted text:
            ```
            gh api -X POST "repos/{REPO}/pulls/{PR_NUMBER}/reviews" \
              -f event="<EVENT>" \
              -f body="<FULL_REVIEW_WITH_ALL_FINDINGS>"
            ```

            Substitute the actual REPO and PR_NUMBER values from the context variables above.

            ## Tool Usage Rules

            **For submitting the review (with inline comments):**
            - `gh api -X POST repos/.../pulls/.../reviews --input -` with JSON containing event, body, and comments array
            - This is the ONLY review submission ‚Äî one call, all findings included

            **For reading data:**
            - `gh api` (GET) ‚Äî read files from other repos, fetch PR metadata
            - `gh pr` ‚Äî read PR details (title, description, files)
            - `Read` tool ‚Äî read local files (e.g., `Read("CLAUDE.md")`). NEVER use Bash to read files.

            **For progress updates:**
            - `gh api -X PATCH repos/.../issues/comments/...` ‚Äî update the progress comment

            **CONSTRAINTS:**
            - Submit exactly ONE review per run. The batched gh api call IS the review ‚Äî never post individual comments separately.
            - NEVER post test, probe, or placeholder reviews. Every API call must be intentional and final.
            - If you encounter permission errors with any tool, do NOT try alternative tools or workarounds. Proceed with what works.
            - `gh api` write operations are ONLY allowed for: (1) submitting the review (POST to reviews endpoint), (2) updating the progress comment (PATCH). No other writes.

            ## Review Quality Standards

            **Quality over quantity**: A review with 3 high-confidence findings is more useful than one with 10 uncertain ones. Filter aggressively.

            **Confidence threshold**: Only flag issues you are confident about. If you're uncertain whether something is actually a problem ‚Äî for example, if the pattern might be intentional, or the context is ambiguous ‚Äî err on the side of not flagging it. Put uncertain observations in the review body summary rather than as inline comments.

            **Verify before flagging**: Always read the full file context around the flagged location before including it in your review. Diff snippets can be misleading ‚Äî a function that looks problematic in the diff may be correct when you see the surrounding code.

            **Actionable findings**: Every inline comment must include a concrete fix suggestion. Don't just identify problems ‚Äî propose solutions. Example:
            - Good: "‚ö†Ô∏è This query interpolates user input. Use parameterized queries instead: `cursor.execute('SELECT * FROM users WHERE id = %s', (user_id,))`"
            - Bad: "‚ö†Ô∏è This query might have a SQL injection issue"

            **Silent failure patterns**: Pay specific attention to these error-handling anti-patterns:
            - Empty `except` or `except Exception: pass` blocks that swallow errors
            - Catch blocks that log but silently continue when the caller expects an exception
            - Returning default values (None, empty list, 0) on error without logging or raising
            - Retry logic that exhausts attempts without surfacing the underlying error
            - Broad exception handlers that catch unrelated errors (e.g., `except Exception` when only `ValueError` is expected)

            **Testing assessment**: Evaluate behavioral coverage, not just whether test files exist. Ask: "Would these tests catch a meaningful regression if this code changed?" Focus on:
            - Critical paths that could cause data loss or security issues if broken
            - Edge cases for boundary conditions (null, empty, overflow)
            - Error handling paths ‚Äî are failure modes tested, not just happy paths?
            - Avoid suggesting tests for trivial code unless it contains business logic

            ## Quantivly Architecture

            Two-layer architecture: platform provides foundational data infrastructure, hub provides user-facing analytics portal.

            **platform** (quantivly-dockers) - Core DICOM/RIS backbone
            | Component | Role | Depends On |
            |-----------|------|------------|
            | box | DICOM harmonization (GE/Philips/Siemens), RIS integration | quantivly-sdk |
            | ptbi | DICOM networking (Python+Java/dcm4che) | quantivly-sdk |
            | auto-conf | Jinja2 stack generator (configures platform AND hub) | ‚Äî |
            | quantivly-sdk | Python SDK for platform services | ‚Äî |

            **hub** (hub repo) - Healthcare analytics portal
            | Repository | Role | Depends On |
            |------------|------|------------|
            | sre-core | Django backend (GraphQL API, plugin system) | sre-sdk |
            | sre-ui | Next.js frontend | sre-core GraphQL |
            | sre-event-bridge | WAMP‚ÜíREST bridge | sre-sdk |
            | sre-postgres | PostgreSQL database | ‚Äî |
            | sre-sdk | Python SDK for hub services | ‚Äî |

            **Connection**: Hub integrates with platform's backbone (Keycloak auth, WAMP router, shared networking). Platform's auto-conf generates deployment configs for both ecosystems.

            ## Review Standards

            Read `.github-org/docs/review-standards.md` for severity levels, checklists, and output format.
            Also read the repository's `CLAUDE.md` if it exists.

            ## Linear Integration

            If a Linear issue ID is provided, use the Linear MCP tools to:
            1. Fetch the issue description and acceptance criteria
            2. Review any comments for additional requirements
            3. Validate the PR implementation aligns with requirements
            4. Flag any gaps between requirements and implementation

            ## Cross-Repository Validation

            When reviewing changes to shared/exported code, validate consumers using `gh api`:

            | Change In | Must Validate Against | Example Check |
            |-----------|----------------------|---------------|
            | sre-core GraphQL schema | sre-ui TypeScript types/queries | `gh api repos/quantivly/sre-ui/contents/src/graphql` |
            | sre-sdk | sre-core, sre-event-bridge | Check imports and API usage |
            | quantivly-sdk | box, ptbi | Check SDK method calls |
            | auto-conf templates | Rendered stack files | Verify Jinja2 renders correctly |

            Use: `gh api repos/quantivly/<repo>/contents/<path>` to fetch files from other repos.

            ## Review Priorities

            1. **Security** - OWASP Top 10, HIPAA compliance, SQL injection, XSS, credentials
            2. **Logic Errors** - Incorrect implementations, edge cases, race conditions
            3. **Code Quality** - Readability, SOLID principles, design patterns
            4. **Testing** - Coverage, edge cases, test quality
            5. **Performance** - N+1 queries, algorithmic efficiency

            ## Healthcare Context

            Extra scrutiny for PHI handling, audit logging, access controls, and HIPAA compliance.

            ## Output Format

            Your review summary (the `body` parameter when submitting the review) should be concise:

            ---

            **Summary**: [1-2 sentences: what the PR does]

            **Linear**: [Issue ID] - [Status: ‚úÖ Aligned / ‚ö†Ô∏è Gaps / ‚ùå Misaligned]

            **Prior reviews**: [If re-review: "Re-review #N. X of Y prior findings addressed. Focusing on new/changed code." If first review: omit this line.]

            **Issues**: [X critical, Y high, Z suggestions] ‚Äî see inline comments

            **Highlights**:
            - ‚úÖ [Notable good practice]
            - ‚úÖ [Another positive]

            ---
            <sub>@${{ github.event.comment.user.login }}<!-- METRICS --> ¬∑ [Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})</sub>

            ---

            **IMPORTANT**: Keep the summary SHORT. All code-specific findings (CRITICAL, HIGH, Suggestion) MUST be included in the `comments` array of the review JSON. The review `body` should only contain the template above ‚Äî never detailed findings.
            If previous reviews exist (PREVIOUS_REVIEW_COUNT > 0), prioritize new findings. Acknowledge addressed issues briefly in the summary. Only re-flag a prior finding as an inline comment if the fix attempt introduced a new problem.
            Start each inline comment body with a severity emoji and then the finding directly:
            - üö® for security and data loss issues (must fix)
            - ‚ö†Ô∏è for bugs and logic errors (should fix)
            - üí° for improvements (nice to have)
            Example: "üö® User input is interpolated into the SQL query without parameterization"

            ## Progress Updates (Optional, Non-Blocking)

            A progress comment has been posted on the PR. Update it at each milestone using:
            ```
            gh api -X PATCH repos/<REPO>/issues/comments/<PROGRESS_COMMENT_ID> -f body='<updated body>'
            ```

            Substitute the actual REPO and PROGRESS_COMMENT_ID values from the context variables above.

            Update at these milestones (use the exact bodies below):

            **After reading review standards / CLAUDE.md:**
            ```
            ü§ñ **Claude review in progress...**

            ‚úÖ Read review standards and repository context
            ‚è≥ Analyzing code changes...
            ```

            **After analyzing the diff, before posting inline comments:**
            ```
            ü§ñ **Claude review in progress...**

            ‚úÖ Read review standards and repository context
            ‚úÖ Analyzed code changes
            ‚è≥ Composing review...
            ```

            Rules:
            - If an update fails, ignore the error and continue with the review. Progress updates are nice-to-have.
            - Do NOT update more than twice. Do NOT update after submitting the review (cleanup is handled automatically).

      - name: Extract execution metrics
        id: extract-metrics
        if: always() && steps.claude-review.outputs.execution_file
        continue-on-error: true
        env:
          EXECUTION_FILE: ${{ steps.claude-review.outputs.execution_file }}
        run: |
          if [ ! -f "$EXECUTION_FILE" ]; then
            echo "Execution file not found: $EXECUTION_FILE"
            exit 0
          fi

          # Cost: from the result turn's total_cost_usd (pre-computed by the SDK)
          COST=$(jq -r '
            [.[] | select(.type == "result")] | last //empty |
            (.total_cost_usd // .cost_usd // empty)
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$COST" ] && [ "$COST" != "null" ]; then
            COST_FMT=$(printf '$%.2f' "$COST")
            echo "cost=$COST_FMT" >> "$GITHUB_OUTPUT"
            echo "Cost: $COST_FMT"
          fi

          # Duration: from the result turn's duration_ms (pre-computed by the SDK)
          DURATION_MS=$(jq -r '
            [.[] | select(.type == "result")] | last //empty |
            .duration_ms // empty
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$DURATION_MS" ] && [ "$DURATION_MS" != "null" ]; then
            TOTAL_SEC=$(( DURATION_MS / 1000 ))
            if [ "$TOTAL_SEC" -ge 60 ]; then
              MINS=$(( TOTAL_SEC / 60 ))
              SECS=$(( TOTAL_SEC % 60 ))
              DURATION_FMT="${MINS}m ${SECS}s"
            else
              DURATION_FMT="${TOTAL_SEC}s"
            fi
            echo "duration=$DURATION_FMT" >> "$GITHUB_OUTPUT"
            echo "Duration: $DURATION_FMT"
          fi

          # Tokens: sum usage across all assistant turns
          TOKENS=$(jq '
            [.[] | select(.type == "assistant") | .message.usage // empty |
              ((.input_tokens // 0) + (.output_tokens // 0) +
               (.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0))
            ] | add // 0
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$TOKENS" ] && [ "$TOKENS" != "null" ] && [ "$TOKENS" -gt 0 ] 2>/dev/null; then
            if [ "$TOKENS" -ge 1000000 ]; then
              # e.g. 1234567 -> "1.2M tokens"
              TOKENS_FMT="$(echo "$TOKENS" | awk '{printf "%.1fM", $1/1000000}') tokens"
            elif [ "$TOKENS" -ge 1000 ]; then
              # e.g. 42300 -> "42k tokens"
              TOKENS_FMT="$(echo "$TOKENS" | awk '{printf "%.0fk", $1/1000}') tokens"
            else
              TOKENS_FMT="${TOKENS} tokens"
            fi
            echo "tokens=$TOKENS_FMT" >> "$GITHUB_OUTPUT"
            echo "Tokens: $TOKENS_FMT"
          fi

          # Model: from the system init message
          MODEL_ID=$(jq -r '
            [.[] | select(.type == "system" and .subtype == "init")] | first //empty |
            .model // empty
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$MODEL_ID" ] && [ "$MODEL_ID" != "null" ]; then
            # Map model IDs to human-readable names
            case "$MODEL_ID" in
              *opus-4-6*)        MODEL_NAME="Opus 4.6" ;;
              *opus-4*)          MODEL_NAME="Opus 4" ;;
              *sonnet-4-5*)      MODEL_NAME="Sonnet 4.5" ;;
              *sonnet-4*)        MODEL_NAME="Sonnet 4" ;;
              *haiku-4-5*)       MODEL_NAME="Haiku 4.5" ;;
              *haiku-4*)         MODEL_NAME="Haiku 4" ;;
              *sonnet*3-5*)      MODEL_NAME="Sonnet 3.5" ;;
              *haiku*3-5*)       MODEL_NAME="Haiku 3.5" ;;
              *)                 MODEL_NAME="$MODEL_ID" ;;
            esac
            echo "model=$MODEL_NAME" >> "$GITHUB_OUTPUT"
            echo "Model: $MODEL_NAME"
          fi

      - name: Update review footer with metrics
        id: update-review-metrics
        if: always() && steps.extract-metrics.outputs.duration
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          METRIC_DURATION: ${{ steps.extract-metrics.outputs.duration }}
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost }}
          METRIC_TOKENS: ${{ steps.extract-metrics.outputs.tokens }}
          METRIC_MODEL: ${{ steps.extract-metrics.outputs.model }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const duration = process.env.METRIC_DURATION || '';
            const cost = process.env.METRIC_COST || '';
            const tokens = process.env.METRIC_TOKENS || '';
            const model = process.env.METRIC_MODEL || '';

            // Build metrics string from available values
            const parts = [];
            if (duration) parts.push(duration);
            if (cost) parts.push(cost);
            if (tokens) parts.push(tokens);
            if (model) parts.push(model);

            if (parts.length === 0) {
              console.log('No metrics to inject');
              return;
            }

            const metricsStr = ' ¬∑ ' + parts.join(' ¬∑ ');
            console.log(`Metrics string: ${metricsStr}`);

            // Find the most recent review containing our metrics marker
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              per_page: 100,
            });

            const claudeReview = reviews
              .filter(r => (r.body || '').includes('<!-- METRICS -->'))
              .pop();

            if (!claudeReview) {
              console.log('No review with metrics marker found');
              return;
            }

            const body = claudeReview.body;

            const updatedBody = body.replace('<!-- METRICS -->', metricsStr);

            await github.rest.pulls.updateReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              review_id: claudeReview.id,
              body: updatedBody,
            });

            console.log(`Updated review ${claudeReview.id} with metrics`);

      - name: Clean up tracking comment
        if: always() && steps.progress.outputs.comment_id
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const commentId = ${{ steps.progress.outputs.comment_id }};
            try {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
              });
              console.log(`Deleted progress comment ${commentId}`);
            } catch (error) {
              console.log(`Failed to delete progress comment ${commentId}: ${error.message}`);
            }

      - name: Post error on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚ùå Claude review failed. Check [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\nTo retry, post a new comment mentioning Claude.`
            });

      - name: Report usage metrics
        if: always()
        env:
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
          TRIGGERED_BY: ${{ github.event.comment.user.login }}
          LINEAR_ID: ${{ steps.linear.outputs.linear_id }}
          CUSTOM_INSTRUCTIONS: ${{ steps.instructions.outputs.custom }}
          PROGRESS_COMMENT_ID: ${{ steps.progress.outputs.comment_id }}
          METRIC_DURATION: ${{ steps.extract-metrics.outputs.duration || 'N/A' }}
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost || 'N/A' }}
          METRIC_TOKENS: ${{ steps.extract-metrics.outputs.tokens || 'N/A' }}
          METRIC_MODEL: ${{ steps.extract-metrics.outputs.model || 'N/A' }}
        run: |
          echo "### Claude Review Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- PR: #${PR_NUMBER}" >> $GITHUB_STEP_SUMMARY
          echo "- Repository: ${REPO}" >> $GITHUB_STEP_SUMMARY
          echo "- Triggered by: @${TRIGGERED_BY}" >> $GITHUB_STEP_SUMMARY
          echo "- Linear Issue: ${LINEAR_ID:-Not specified}" >> $GITHUB_STEP_SUMMARY
          echo "- Custom Focus: ${CUSTOM_INSTRUCTIONS:-Standard review}" >> $GITHUB_STEP_SUMMARY
          echo "- Progress Comment ID: ${PROGRESS_COMMENT_ID:-N/A}" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Execution Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- Duration: ${METRIC_DURATION}" >> $GITHUB_STEP_SUMMARY
          echo "- Cost: ${METRIC_COST}" >> $GITHUB_STEP_SUMMARY
          echo "- Tokens: ${METRIC_TOKENS}" >> $GITHUB_STEP_SUMMARY
          echo "- Model: ${METRIC_MODEL}" >> $GITHUB_STEP_SUMMARY
