name: Claude PR Review

on:
  # Direct trigger for PRs in this (.github) repository
  issue_comment:
    types: [created]

  # Reusable workflow trigger for other repositories in the organization
  workflow_call:
    secrets:
      ANTHROPIC_API_KEY:
        required: true
        description: Anthropic API key for Claude API access
      LINEAR_API_KEY:
        required: false
        description: Linear API key for issue context retrieval
      CLAUDE_APP_PRIVATE_KEY:
        required: false
        description: GitHub App private key for posting reviews as Claude[bot]

# Defensive concurrency: prevents parallel reviews on the same PR.
# Callers should also have their own concurrency block, but this is a safety net.
concurrency:
  group: claude-review-${{ github.repository }}-${{ github.event.issue.number || github.event.number }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  claude-review:
    # Run on workflow_call (caller already filtered) or direct PR comments from humans
    if: |
      github.event_name == 'workflow_call' ||
      (github.event.issue.pull_request &&
       contains(github.event.comment.body, '@claude') &&
       github.event.comment.user.type != 'Bot')

    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Validate commenter permissions
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            // workflow_call events have no comment payload â€” the caller workflow
            // handles its own filtering, so we trust it and skip permission checks.
            if (context.eventName === 'workflow_call') {
              console.log('Triggered via workflow_call â€” permission check handled by caller');
              return true;
            }

            const commenter = context.payload.comment.user.login;
            const repo = context.repo;

            // Try org membership first
            try {
              await github.rest.orgs.checkMembershipForUser({
                org: repo.owner,
                username: commenter,
              });
              console.log(`âœ“ ${commenter} is organization member`);
              return true;
            } catch (orgError) {
              // Check if repo collaborator with write access
              try {
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: repo.owner,
                  repo: repo.repo,
                  username: commenter,
                });
                if (['write', 'admin', 'maintain'].includes(permission.permission)) {
                  console.log(`âœ“ ${commenter} is collaborator with ${permission.permission} access`);
                  return true;
                }
              } catch (e) {}
              console.log(`âœ— ${commenter} does not have sufficient permissions`);
              return false;
            }

      - name: Post permission denied
        if: steps.validate.outputs.result == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: 'âš ï¸ Claude reviews are only available to organization members and repository collaborators with write access.'
            });

      - name: Generate GitHub App token
        id: app-token
        if: steps.validate.outputs.result != 'false' && vars.CLAUDE_APP_ID != ''
        uses: actions/create-github-app-token@v2
        continue-on-error: true
        with:
          app-id: ${{ vars.CLAUDE_APP_ID }}
          private-key: ${{ secrets.CLAUDE_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout repository
        if: steps.validate.outputs.result != 'false'
        uses: actions/checkout@v4
        with:
          ref: refs/pull/${{ github.event.issue.number }}/head

      - name: Checkout .github repository for review standards
        if: steps.validate.outputs.result != 'false'
        uses: actions/checkout@v4
        with:
          repository: quantivly/.github
          path: .github-org
          sparse-checkout: |
            docs/review-standards.md
            docs/review-examples-compact.md
            prompts/review-prompt.txt
          fetch-depth: 1

      - name: Extract Linear issue ID
        id: linear
        if: steps.validate.outputs.result != 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            const match = pr.title.match(/^([A-Z]{2,6}-\d{1,6})/);
            core.setOutput('linear_id', match ? match[1] : '');
            console.log(match ? `Linear issue: ${match[1]}` : 'No Linear issue ID in PR title');

      - name: Extract custom instructions
        id: instructions
        if: steps.validate.outputs.result != 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload?.comment?.body;
            if (!body) {
              core.setOutput('custom', '');
              core.setOutput('force', 'false');
              return;
            }

            // Detect force flag: @claude force anywhere in the comment
            let forceReview = false;
            if (/@claude\s+force\b/i.test(body)) {
              forceReview = true;
              console.log('Force flag detected â€” will bypass staleness check');
            }

            // Pass full comment as context, replacing @claude mentions with "Claude"
            // for natural readability and stripping the "force" keyword
            let instructions = body
              .replace(/@claude\s+force\b/gi, 'Claude')
              .replace(/@claude\b/gi, 'Claude')
              .trim();

            // Check if remaining text is generic (just "Claude" or "Claude review this" etc.)
            const generic = ['', 'claude', 'claude review', 'claude please review', 'claude review this',
                             'claude please review this', 'claude review this pr', 'claude please review this pr'];
            if (generic.includes(instructions.toLowerCase())) {
              core.setOutput('custom', '');
              core.setOutput('force', forceReview ? 'true' : 'false');
              return;
            }
            // Truncate to prevent prompt stuffing
            if (instructions.length > 2000) {
              instructions = instructions.substring(0, 2000) + '... (truncated)';
            }
            core.setOutput('custom', instructions);
            core.setOutput('force', forceReview ? 'true' : 'false');

      - name: Fetch previous review context
        id: previous-reviews
        if: steps.validate.outputs.result != 'false'
        uses: actions/github-script@v7
        env:
          APP_SLUG: ${{ steps.app-token.outputs.app-slug }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue?.number;
            if (!prNumber) {
              core.setOutput('context', '');
              core.setOutput('count', '0');
              console.log('No PR number available â€” skipping previous review fetch');
              return;
            }
            const repo = context.repo;

            // Derive bot login from the GitHub App slug (e.g. "quantivly-reviews" â†’ "quantivly-reviews[bot]")
            // Falls back to github-actions[bot] when no App token is available
            const appSlug = process.env.APP_SLUG;
            const botLogin = appSlug ? `${appSlug}[bot]` : 'github-actions[bot]';
            console.log(`Looking for reviews by: ${botLogin}`);

            // Fetch all reviews on this PR
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            // Identify Claude reviews by bot identity
            const claudeReviews = reviews.filter(r => r.user.login === botLogin);

            if (claudeReviews.length === 0) {
              core.setOutput('context', '');
              core.setOutput('count', '0');
              console.log('No previous Claude reviews found');
              return;
            }

            const reviewCount = claudeReviews.length;
            // Find the latest review with a meaningful body for the summary
            // (some reviews are inline-comment-only with empty bodies)
            const latest = claudeReviews.filter(r => (r.body || '').length > 0).pop()
              || claudeReviews[claudeReviews.length - 1];

            // Extract body summary: strip the <sub> footer and cap length
            let bodySummary = (latest.body || '').replace(/<sub>[\s\S]*?<\/sub>/g, '').trim();
            if (bodySummary.length > 800) {
              bodySummary = bodySummary.substring(0, 800) + '...';
            }

            // Fetch inline comments for the latest review
            const { data: allComments } = await github.rest.pulls.listReviewComments({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const reviewComments = allComments
              .filter(c => c.pull_request_review_id === latest.id)
              .map(c => {
                const firstSentence = (c.body || '').split(/[.\n]/)[0].trim();
                const entry = `- \`${c.path}:${c.line || c.original_line || '?'}\` ${firstSentence}`;
                return entry.length > 120 ? entry.substring(0, 117) + '...' : entry;
              });

            // Build context string
            const date = new Date(latest.submitted_at).toISOString().split('T')[0];
            let contextStr = `Previous Claude reviews: ${reviewCount}\n`;
            contextStr += `Latest review: ${date} (${latest.state})\n\n`;
            contextStr += `### Latest Review Summary\n${bodySummary}\n`;

            if (reviewComments.length > 0) {
              contextStr += `\n### Latest Review Inline Findings (${reviewComments.length})\n`;
              contextStr += reviewComments.join('\n');
            }

            // Hard cap at 4000 chars to control token budget
            if (contextStr.length > 4000) {
              contextStr = contextStr.substring(0, 3997) + '...';
            }

            core.setOutput('context', contextStr);
            core.setOutput('count', String(reviewCount));
            // Output the commit SHA the latest review was submitted on (for staleness detection)
            core.setOutput('last_review_commit', latest.commit_id || '');
            // Output the latest review state (APPROVED, CHANGES_REQUESTED, COMMENTED, DISMISSED)
            core.setOutput('last_review_state', latest.state || '');
            console.log(`Found ${reviewCount} previous Claude review(s). Context: ${contextStr.length} chars`);
            console.log(`Latest review commit: ${latest.commit_id || 'unknown'}, state: ${latest.state || 'unknown'}`);

      - name: Check for stale re-reviews
        id: staleness
        if: steps.validate.outputs.result != 'false' && steps.previous-reviews.outputs.count >= 1
        uses: actions/github-script@v7
        with:
          script: |
            const forceFlag = '${{ steps.instructions.outputs.force }}' === 'true';

            if (forceFlag) {
              console.log('Force flag set â€” bypassing staleness check');
              core.setOutput('skip', 'false');
              return;
            }

            const prNumber = context.issue.number;
            const repo = context.repo;
            const lastReviewCommit = '${{ steps.previous-reviews.outputs.last_review_commit }}';
            const lastReviewState = '${{ steps.previous-reviews.outputs.last_review_state }}';
            const reviewCount = parseInt('${{ steps.previous-reviews.outputs.count }}', 10);

            if (!lastReviewCommit) {
              console.log('No commit SHA from last review â€” cannot detect staleness');
              core.setOutput('skip', 'false');
              return;
            }

            // Get the PR's current head SHA
            const { data: pr } = await github.rest.pulls.get({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
            });
            const currentHead = pr.head.sha;
            console.log(`Current HEAD: ${currentHead}, Last review commit: ${lastReviewCommit}, State: ${lastReviewState}`);

            if (currentHead === lastReviewCommit) {
              // Skip if already approved on this commit (no point re-reviewing)
              if (lastReviewState === 'APPROVED') {
                console.log('Stale: last review was APPROVE on this commit â€” no re-review needed');
              } else {
                console.log(`Stale: ${reviewCount} prior reviews and no code changes since last review`);
              }
              core.setOutput('skip', 'true');
            } else {
              console.log('Code has changed since last review â€” proceeding');
              core.setOutput('skip', 'false');
            }

      - name: Post stale review notice
        if: steps.staleness.outputs.skip == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const count = '${{ steps.previous-reviews.outputs.count }}';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ðŸ”„ **Skipping review** â€” no code changes since the last review (${count} prior reviews on the same commit). Previous review findings still apply.\n\nPush new commits and then trigger \`@claude\` again for a fresh review.\n\n_Tip: Use \`@claude force\` to bypass this check and re-review unchanged code._`,
            });

      - name: Compute diff since last review
        id: delta
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true' && steps.previous-reviews.outputs.last_review_commit != ''
        continue-on-error: true
        env:
          LAST_REVIEW_COMMIT: ${{ steps.previous-reviews.outputs.last_review_commit }}
        run: |
          # Compute what changed since the last review for focused re-review
          DELTA=$(git diff "$LAST_REVIEW_COMMIT"..HEAD --stat 2>/dev/null || echo "Unable to compute delta â€” commit may have been force-pushed")
          {
            echo "delta<<DELTA_EOF"
            echo "$DELTA" | head -50
            echo "DELTA_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create MCP config for Linear
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
        run: |
          # Create .mcp.json with explicit auth headers for Linear MCP server
          # GitHub Actions needs explicit Bearer auth in .mcp.json
          # (locally, Claude Code auto-injects auth from env vars)
          if [ -n "$LINEAR_API_KEY" ]; then
            printf '{"mcpServers":{"linear":{"type":"http","url":"https://mcp.linear.app/mcp","headers":{"Authorization":"Bearer %s"}}}}' "$LINEAR_API_KEY" > .mcp.json
            echo "Created .mcp.json with Linear MCP server auth configuration"
          else
            echo "LINEAR_API_KEY not set, skipping MCP config"
          fi

      - name: Assess PR complexity
        id: complexity
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const repo = context.repo;

            // Paginate to handle PRs with 100+ files (GitHub returns max 100 per page)
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const totalAdditions = files.reduce((sum, f) => sum + f.additions, 0);
            const totalDeletions = files.reduce((sum, f) => sum + f.deletions, 0);
            const diffLines = totalAdditions + totalDeletions;
            const fileCount = files.length;
            const filenames = files.map(f => f.filename);

            console.log(`PR stats: ${diffLines} diff lines across ${fileCount} files`);

            // Check if PR is docs/config-only
            const docsConfigExtensions = /\.(md|yml|yaml|json|txt|toml|cfg|ini|env\.example)$/;
            const isDocsConfigOnly = filenames.every(f => docsConfigExtensions.test(f));

            // Check if docs/config includes infrastructure YAML (workflows, Docker, k8s)
            // These contain security-sensitive configuration and should not be reviewed with Haiku
            const infraPatterns = /(workflow|docker|k8s|helm|deploy|infra|compose)/i;
            const hasInfraYaml = filenames.some(f =>
              /\.(yml|yaml)$/.test(f) && infraPatterns.test(f)
            );

            // Check if PR touches security-sensitive paths
            // Note: 'access' was removed (too broad â€” matches accessibility.py, data_access_layer.py)
            const securityPaths = /(auth|security|login|password|token|session|permission|crypto|encrypt|hipaa|phi|middleware|migration|webhook|oauth|saml|keycloak|audit|secret|credential)/i;
            const securityFileCount = filenames.filter(f => securityPaths.test(f)).length;

            // Scan diff patches for PHI-related keywords (catches PHI handling regardless of filename)
            const phiKeywords = /(patient|mrn|medical_record|ssn|social_security|date_of_birth|dob|diagnosis|phi_|hipaa)/i;
            const diffContainsPhi = files.some(f => phiKeywords.test(f.patch || ''));
            if (diffContainsPhi) {
              console.log('PHI-related keywords detected in diff content â€” escalating to opus');
            }

            // Weighted complexity score: new code needs more scrutiny than deleted code,
            // and security-sensitive files escalate regardless of diff size
            const complexityScore = (totalAdditions * 1.0) + (totalDeletions * 0.3) + (securityFileCount * 200);

            // Model selection: docs/config â†’ haiku, complex/security/PHI â†’ opus, default â†’ sonnet
            // Model IDs are mapped here so claude_args can use --model directly
            const modelMap = {
              haiku: 'claude-haiku-4-5-20251001',
              sonnet: 'claude-sonnet-4-5-20250929',
              opus: 'claude-opus-4-6',
            };
            let modelTier = 'sonnet';
            if (isDocsConfigOnly && !hasInfraYaml) {
              modelTier = 'haiku';
            } else if (isDocsConfigOnly && hasInfraYaml) {
              modelTier = 'sonnet';
            } else if (complexityScore > 500 || diffContainsPhi) {
              modelTier = 'opus';
            } else if (securityFileCount >= 1 && totalAdditions >= 10) {
              // Small but non-trivial changes to security-sensitive files deserve
              // Opus scrutiny even if the overall complexity score is below 500
              modelTier = 'opus';
              console.log(`Security escalation: ${securityFileCount} security file(s) with ${totalAdditions} additions`);
            }
            const model = modelMap[modelTier];

            // Adaptive comment cap: scale with diff size, min 3
            // Opus gets a higher ceiling (18) since it handles the most complex PRs
            const maxCap = modelTier === 'opus' ? 18 : 12;
            const commentCap = Math.max(3, Math.min(maxCap, Math.ceil(diffLines / 50)));

            console.log(`Model: ${modelTier} (${model}), Comment cap: ${commentCap}`);
            core.setOutput('model', model);
            core.setOutput('model_tier', modelTier);
            core.setOutput('comment_cap', String(commentCap));
            core.setOutput('diff_lines', String(diffLines));

      - name: Post progress comment
        id: progress
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        uses: actions/github-script@v7
        env:
          MODEL_TIER: ${{ steps.complexity.outputs.model_tier }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const tier = process.env.MODEL_TIER || 'sonnet';
            const tierInfo = {
              haiku: { name: 'Haiku 4.5', time: '~1-2 minutes', desc: 'docs/config review' },
              sonnet: { name: 'Sonnet 4.5', time: '~2-4 minutes', desc: 'standard code review' },
              opus: { name: 'Opus 4.6', time: '~3-7 minutes', desc: 'large/security-sensitive review' },
            };
            const info = tierInfo[tier] || tierInfo.sonnet;
            const body = `ðŸ¤– **Claude review started...** Using ${info.name} (${info.desc}). Expected: ${info.time}.\n\n_Analyzing code for security, logic errors, code quality, testing, and performance._`;
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
            core.setOutput('comment_id', comment.id);
            console.log(`Posted progress comment ${comment.id}`);

      - name: Fetch CI status
        id: ci-status
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        uses: actions/github-script@v7
        env:
          PROGRESS_COMMENT_ID: ${{ steps.progress.outputs.comment_id }}
          MODEL_TIER: ${{ steps.complexity.outputs.model_tier }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const MAX_CI_WAIT_MS = 300000; // 5 minutes
            const POLL_INTERVAL_MS = 20000; // 20 seconds
            const SELF_CHECK_NAME = 'Claude PR Review';

            const repo = context.repo;
            const prNumber = context.issue.number;
            const commentId = process.env.PROGRESS_COMMENT_ID;
            const modelTier = process.env.MODEL_TIER || 'sonnet';

            // Get PR head SHA
            const { data: pr } = await github.rest.pulls.get({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
            });
            let headSha = pr.head.sha;
            console.log(`PR head SHA: ${headSha}`);

            // Helper: format relative time (e.g., "2h ago", "5m ago")
            function relativeTime(dateStr) {
              const diffMs = Date.now() - new Date(dateStr).getTime();
              const mins = Math.floor(diffMs / 60000);
              if (mins < 60) return `${mins}m ago`;
              const hours = Math.floor(mins / 60);
              if (hours < 24) return `${hours}h ago`;
              return `${Math.floor(hours / 24)}d ago`;
            }

            // Helper: fetch all check runs for a SHA, filtering out self
            // Note: paginate() auto-extracts the check_runs array from the nested
            // Checks API response â€” no mapFn needed (adding one breaks extraction)
            async function fetchCheckRuns(sha) {
              const checkRuns = await github.paginate(
                github.rest.checks.listForRef,
                { owner: repo.owner, repo: repo.repo, ref: sha, per_page: 100 }
              );
              return checkRuns.filter(cr => cr.name !== SELF_CHECK_NAME);
            }

            // Helper: categorize check runs
            function categorize(checkRuns) {
              const failed = [];
              const passed = [];
              const pending = [];
              for (const cr of checkRuns) {
                if (cr.status === 'completed') {
                  if (cr.conclusion === 'success' || cr.conclusion === 'skipped' || cr.conclusion === 'neutral') {
                    passed.push(cr);
                  } else {
                    failed.push(cr);
                  }
                } else {
                  pending.push(cr);
                }
              }
              return { failed, passed, pending };
            }

            // Helper: update progress comment (non-blocking)
            async function updateProgress(body) {
              if (!commentId) return;
              try {
                await github.rest.issues.updateComment({
                  owner: repo.owner,
                  repo: repo.repo,
                  comment_id: commentId,
                  body,
                });
              } catch (e) {
                console.log(`Progress comment update failed (non-blocking): ${e.message}`);
              }
            }

            // Phase A: Initial check
            let checkRuns = await fetchCheckRuns(headSha);
            let { failed, passed, pending } = categorize(checkRuns);
            console.log(`Initial CI status: ${failed.length} failed, ${passed.length} passed, ${pending.length} pending`);

            // Phase B: Wait for pending checks (if any)
            if (pending.length > 0) {
              const tierInfo = {
                haiku: { name: 'Haiku 4.5' },
                sonnet: { name: 'Sonnet 4.5' },
                opus: { name: 'Opus 4.6' },
              };
              const modelName = (tierInfo[modelTier] || tierInfo.sonnet).name;

              await updateProgress(
                `ðŸ¤– **Claude review started...** Using ${modelName} (standard code review).\n\n` +
                `â³ Waiting for CI checks to complete (${pending.length} running)...\n` +
                `_Review will begin once CI finishes (max wait: 5 minutes)._`
              );

              const startTime = Date.now();
              let lastProgressUpdate = startTime;

              while (pending.length > 0 && (Date.now() - startTime) < MAX_CI_WAIT_MS) {
                await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));

                // Re-fetch PR to check if head SHA changed (new commit pushed)
                const { data: currentPr } = await github.rest.pulls.get({
                  owner: repo.owner,
                  repo: repo.repo,
                  pull_number: prNumber,
                });
                if (currentPr.head.sha !== headSha) {
                  console.log(`Head SHA changed during wait (${headSha} â†’ ${currentPr.head.sha}) â€” aborting CI wait`);
                  headSha = currentPr.head.sha;
                  break;
                }

                // Re-fetch check runs
                checkRuns = await fetchCheckRuns(headSha);
                ({ failed, passed, pending } = categorize(checkRuns));

                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                console.log(`CI poll (${elapsed}s): ${failed.length} failed, ${passed.length} passed, ${pending.length} pending`);

                // Update progress comment every ~60s
                if (Date.now() - lastProgressUpdate >= 60000) {
                  const elapsedMin = Math.floor(elapsed / 60);
                  const elapsedSec = elapsed % 60;
                  await updateProgress(
                    `ðŸ¤– **Claude review started...** Using ${modelName} (standard code review).\n\n` +
                    `â³ Waiting for CI checks to complete (${pending.length} still running, ${elapsedMin}m ${elapsedSec}s elapsed)...\n` +
                    `_Review will begin once CI finishes (max wait: 5 minutes)._`
                  );
                  lastProgressUpdate = Date.now();
                }
              }
            }

            // Build final CI status string
            const lines = [];
            if (failed.length > 0) {
              lines.push(`Failed (${failed.length}):`);
              for (const cr of failed.slice(0, 10)) {
                const time = cr.completed_at ? relativeTime(cr.completed_at) : '';
                const name = cr.html_url
                  ? `[âŒ ${cr.name}](${cr.html_url})`
                  : `âŒ ${cr.name}`;
                lines.push(`  - ${name}${time ? ` (${time})` : ''}`);
              }
              if (failed.length > 10) {
                lines.push(`  - ... and ${failed.length - 10} more`);
              }
            }
            if (passed.length > 0) {
              lines.push(`âœ… ${passed.length} passed`);
            }
            if (pending.length > 0) {
              lines.push(`â³ Still running â€” timed out waiting (${pending.length}):`);
              for (const cr of pending.slice(0, 5)) {
                lines.push(`  - ${cr.name}`);
              }
              if (pending.length > 5) {
                lines.push(`  - ... and ${pending.length - 5} more`);
              }
            }

            if (checkRuns.length === 0) {
              lines.push('No CI checks found for this commit.');
            }

            let ciStatus = lines.join('\n');
            // Cap at 2000 chars
            if (ciStatus.length > 2000) {
              ciStatus = ciStatus.substring(0, 1997) + '...';
            }

            const ciFailing = failed.length > 0 ? 'true' : 'false';
            core.setOutput('ci_status', ciStatus);
            core.setOutput('ci_failing', ciFailing);
            console.log(`CI failing: ${ciFailing}`);
            console.log(`CI status:\n${ciStatus}`);

            // Escalate model from Haiku to Sonnet when CI is failing.
            // Investigating CI logs requires stronger reasoning than docs/config review.
            let effectiveTier = modelTier;
            if (ciFailing === 'true' && modelTier === 'haiku') {
              effectiveTier = 'sonnet';
              core.setOutput('model_override', 'claude-sonnet-4-5-20250929');
              core.setOutput('model_tier_override', 'sonnet');
              console.log('CI failure detected â€” escalating model from Haiku to Sonnet for log investigation');
            }

            // Update progress comment with CI results before handing off to Claude
            const tierInfo2 = {
              haiku: { name: 'Haiku 4.5', desc: 'docs/config review' },
              sonnet: { name: 'Sonnet 4.5', desc: 'standard code review' },
              opus: { name: 'Opus 4.6', desc: 'large/security-sensitive review' },
            };
            const info = tierInfo2[effectiveTier] || tierInfo2.sonnet;

            const ciSummaryLine = failed.length > 0
              ? `âŒ CI checks complete (${failed.length} failed, ${passed.length} passed)`
              : pending.length > 0
                ? `âš ï¸ CI checks: ${passed.length} passed, ${pending.length} still running`
                : `âœ… CI checks complete (${passed.length} passed)`;

            await updateProgress(
              `ðŸ¤– **Claude review in progress...** Using ${info.name} (${info.desc}).\n\n` +
              `${ciSummaryLine}\n` +
              `â³ Analyzing code changes...`
            );

      - name: Build review configuration
        id: review-config
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        run: |
          # Shared review configuration used by both the primary attempt and retry steps.
          # claude_args: tool allowlist, model selection, MCP config, and tier-scaled max-turns
          # CI status step may override model tier (e.g., Haiku â†’ Sonnet when CI is failing)
          MODEL_TIER="${{ steps.ci-status.outputs.model_tier_override || steps.complexity.outputs.model_tier }}"
          case "$MODEL_TIER" in
            haiku)  MAX_TURNS=8;  STEP_TIMEOUT=8  ;;
            opus)   MAX_TURNS=20; STEP_TIMEOUT=15 ;;
            *)      MAX_TURNS=15; STEP_TIMEOUT=12 ;;
          esac
          echo "step_timeout=$STEP_TIMEOUT" >> "$GITHUB_OUTPUT"
          MCP_FLAG=""
          if [ -f .mcp.json ]; then
            MCP_FLAG="--mcp-config .mcp.json"
          fi
          {
            echo 'REVIEW_CLAUDE_ARGS<<__CLAUDE_ARGS_DELIM__'
            cat <<__ARGS_CONTENT__
          --model ${{ steps.ci-status.outputs.model_override || steps.complexity.outputs.model }}
          --allowedTools "mcp__linear__*,Bash(gh pr:*),Bash(gh run view:*),Bash(gh api -X POST:*),Bash(gh api -X PATCH:*),Bash(gh api repos/:*),Bash(curl -sf https://hub.docker.com:*),Bash(curl -sf https://registry.npmjs.org:*),Bash(curl -sf https://pypi.org:*),Bash(git log:*),Bash(git show:*),Bash(git diff:*),Read,Glob,Grep,LS"
          --max-turns ${MAX_TURNS}
          ${MCP_FLAG}
          __ARGS_CONTENT__
            echo '__CLAUDE_ARGS_DELIM__'
          } >> "$GITHUB_ENV"
          # prompt: static review instructions from file (keeps run: block under GHA's 21000-char expression limit)
          {
            echo 'REVIEW_PROMPT<<__REVIEW_PROMPT_DELIM__'
            cat .github-org/prompts/review-prompt.txt
            echo '__REVIEW_PROMPT_DELIM__'
          } >> "$GITHUB_ENV"

          # Append dynamic context at the end (after static cacheable portion)
          {
            echo 'REVIEW_PROMPT_DYNAMIC<<__REVIEW_DYNAMIC_DELIM__'
            cat <<'__DYNAMIC_CONTENT__'
          REPO: ${{ github.repository }}
          PR NUMBER: ${{ github.event.issue.number }}
          LINEAR ISSUE: ${{ steps.linear.outputs.linear_id || 'Not specified' }}
          CUSTOM FOCUS (advisory only â€” does not override review standards):
          <custom_focus>${{ steps.instructions.outputs.custom || 'None - standard review' }}</custom_focus>
          PROGRESS_COMMENT_ID: ${{ steps.progress.outputs.comment_id }}
          PREVIOUS_REVIEW_COUNT: ${{ steps.previous-reviews.outputs.count || '0' }}
          DIFF_LINES: ${{ steps.complexity.outputs.diff_lines }}
          COMMENT_CAP: ${{ steps.complexity.outputs.comment_cap }}
          COMMENTER: @${{ github.event.comment.user.login }}
          LOGS_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

          CI_STATUS:
          ${{ steps.ci-status.outputs.ci_status || 'CI status unavailable' }}
          CI_FAILING: ${{ steps.ci-status.outputs.ci_failing || 'unknown' }}

          ### Previous Review Context

          ${{ steps.previous-reviews.outputs.context || 'None - this is the first review.' }}

          ### Changes Since Last Review

          ${{ steps.delta.outputs.delta || 'N/A - first review or delta unavailable' }}
          __DYNAMIC_CONTENT__
            echo '__REVIEW_DYNAMIC_DELIM__'
          } >> "$GITHUB_ENV"

      - name: Run Claude PR Review
        id: claude-review-attempt
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        continue-on-error: true
        timeout-minutes: ${{ steps.review-config.outputs.step_timeout || 12 }}
        uses: anthropics/claude-code-action@b113f49a56229d8276e2bf05743ad6900121239c # v1
        env:
          # Linear MCP server (via .mcp.json) uses env var for API authentication
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          # gh CLI reads from GH_TOKEN env var (using GH_ prefix since GitHub reserves GITHUB_)
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          # Allow tools for PR review:
          # - Linear MCP tools (issue context, requirements) via --mcp-config in claude_args
          # - gh CLI for: reading PR data, CI run logs, cross-repo files, submitting batched review, progress updates
          # - File tools for reading codebase
          # - git for commit history context
          # Review submission uses gh api POST to /reviews with comments array (single review event)
          # gh api scoped to: POST reviews, PATCH progress comments, GET cross-repo files
          # gh run view: read-only access to CI run logs for failure investigation
          claude_args: ${{ env.REVIEW_CLAUDE_ARGS }}
          # Static prompt (cacheable) + dynamic PR context (appended at end)
          prompt: "${{ env.REVIEW_PROMPT }}\n${{ env.REVIEW_PROMPT_DYNAMIC }}"

      - name: Check if review was posted despite failure
        id: review-check
        if: steps.claude-review-attempt.outcome == 'failure' && !steps.claude-review-attempt.outputs.execution_file
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          APP_SLUG: ${{ steps.app-token.outputs.app-slug }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue?.number;
            if (!prNumber) {
              core.setOutput('review_posted', 'false');
              return;
            }

            const appSlug = process.env.APP_SLUG;
            const botLogin = appSlug ? `${appSlug}[bot]` : 'github-actions[bot]';

            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });
            const currentCount = reviews.filter(r => r.user.login === botLogin).length;
            const previousCount = parseInt('${{ steps.previous-reviews.outputs.count }}', 10) || 0;

            if (currentCount > previousCount) {
              console.log(`Review was posted despite action failure (${previousCount} â†’ ${currentCount}). Skipping retry.`);
              core.setOutput('review_posted', 'true');
            } else {
              console.log(`No new review detected (count still ${currentCount}). Retry is appropriate.`);
              core.setOutput('review_posted', 'false');
            }

      - name: Post partial failure notice
        if: steps.review-check.outputs.review_posted == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `âš ï¸ Review posted successfully, but the action encountered a post-review error (execution metrics unavailable). [Workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) may have details.`,
            });

      - name: Update progress comment for retry
        if: steps.claude-review-attempt.outcome == 'failure' && !steps.claude-review-attempt.outputs.execution_file && steps.review-check.outputs.review_posted != 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const commentId = '${{ steps.progress.outputs.comment_id }}';
            if (!commentId) return;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: 'ðŸ¤– **Claude review retrying...**\n\nâš ï¸ First attempt did not complete successfully. Retrying automatically...',
            });

      - name: Run Claude PR Review (retry)
        id: claude-review-retry
        if: steps.claude-review-attempt.outcome == 'failure' && !steps.claude-review-attempt.outputs.execution_file && steps.review-check.outputs.review_posted != 'true'
        timeout-minutes: ${{ steps.review-config.outputs.step_timeout || 12 }}
        uses: anthropics/claude-code-action@b113f49a56229d8276e2bf05743ad6900121239c # v1
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          claude_args: ${{ env.REVIEW_CLAUDE_ARGS }}
          prompt: "${{ env.REVIEW_PROMPT }}\n${{ env.REVIEW_PROMPT_DYNAMIC }}"

      - name: Extract execution metrics
        id: extract-metrics
        if: always() && (steps.claude-review-retry.outputs.execution_file || steps.claude-review-attempt.outputs.execution_file)
        continue-on-error: true
        env:
          EXECUTION_FILE: ${{ steps.claude-review-retry.outputs.execution_file || steps.claude-review-attempt.outputs.execution_file }}
        run: |
          if [ ! -f "$EXECUTION_FILE" ]; then
            echo "Execution file not found: $EXECUTION_FILE"
            exit 0
          fi

          # Cost: from the result turn's total_cost_usd (pre-computed by the SDK)
          COST=$(jq -r '
            [.[] | select(.type == "result")] | last //empty |
            (.total_cost_usd // .cost_usd // empty)
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$COST" ] && [ "$COST" != "null" ]; then
            COST_FMT=$(printf '$%.2f' "$COST")
            echo "cost=$COST_FMT" >> "$GITHUB_OUTPUT"
            echo "Cost: $COST_FMT"
          fi

          # Duration: from the result turn's duration_ms (pre-computed by the SDK)
          DURATION_MS=$(jq -r '
            [.[] | select(.type == "result")] | last //empty |
            .duration_ms // empty
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$DURATION_MS" ] && [ "$DURATION_MS" != "null" ]; then
            TOTAL_SEC=$(( DURATION_MS / 1000 ))
            if [ "$TOTAL_SEC" -ge 60 ]; then
              MINS=$(( TOTAL_SEC / 60 ))
              SECS=$(( TOTAL_SEC % 60 ))
              DURATION_FMT="${MINS}m ${SECS}s"
            else
              DURATION_FMT="${TOTAL_SEC}s"
            fi
            echo "duration=$DURATION_FMT" >> "$GITHUB_OUTPUT"
            echo "Duration: $DURATION_FMT"
          fi

          # Tokens: sum usage across all assistant turns
          TOKENS=$(jq '
            [.[] | select(.type == "assistant") | .message.usage // empty |
              ((.input_tokens // 0) + (.output_tokens // 0) +
               (.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0))
            ] | add // 0
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$TOKENS" ] && [ "$TOKENS" != "null" ] && [ "$TOKENS" -gt 0 ] 2>/dev/null; then
            if [ "$TOKENS" -ge 1000000 ]; then
              # e.g. 1234567 -> "1.2M tokens"
              TOKENS_FMT="$(echo "$TOKENS" | awk '{printf "%.1fM", $1/1000000}') tokens"
            elif [ "$TOKENS" -ge 1000 ]; then
              # e.g. 42300 -> "42k tokens"
              TOKENS_FMT="$(echo "$TOKENS" | awk '{printf "%.0fk", $1/1000}') tokens"
            else
              TOKENS_FMT="${TOKENS} tokens"
            fi
            echo "tokens=$TOKENS_FMT" >> "$GITHUB_OUTPUT"
            echo "Tokens: $TOKENS_FMT"
          fi

          # Cache: separate cache read vs creation tokens
          CACHE_READ=$(jq '
            [.[] | select(.type == "assistant") | .message.usage // empty |
              (.cache_read_input_tokens // 0)
            ] | add // 0
          ' "$EXECUTION_FILE" 2>/dev/null)
          CACHE_CREATION=$(jq '
            [.[] | select(.type == "assistant") | .message.usage // empty |
              (.cache_creation_input_tokens // 0)
            ] | add // 0
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$CACHE_READ" ] && [ "$CACHE_READ" != "null" ] && [ "$CACHE_READ" -gt 0 ] 2>/dev/null; then
            if [ "$CACHE_READ" -ge 1000 ]; then
              CACHE_READ_FMT="$(echo "$CACHE_READ" | awk '{printf "%.0fk", $1/1000}')"
            else
              CACHE_READ_FMT="$CACHE_READ"
            fi
            echo "cache_read=${CACHE_READ_FMT} cached" >> "$GITHUB_OUTPUT"
            echo "Cache read: ${CACHE_READ_FMT}"
          fi
          if [ -n "$CACHE_CREATION" ] && [ "$CACHE_CREATION" != "null" ] && [ "$CACHE_CREATION" -gt 0 ] 2>/dev/null; then
            if [ "$CACHE_CREATION" -ge 1000 ]; then
              CACHE_CREATION_FMT="$(echo "$CACHE_CREATION" | awk '{printf "%.0fk", $1/1000}')"
            else
              CACHE_CREATION_FMT="$CACHE_CREATION"
            fi
            echo "cache_creation=${CACHE_CREATION_FMT} new cache" >> "$GITHUB_OUTPUT"
            echo "Cache creation: ${CACHE_CREATION_FMT}"
          fi

          # Model: from the system init message
          MODEL_ID=$(jq -r '
            [.[] | select(.type == "system" and .subtype == "init")] | first //empty |
            .model // empty
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$MODEL_ID" ] && [ "$MODEL_ID" != "null" ]; then
            # Map model IDs to human-readable names
            case "$MODEL_ID" in
              *opus-4-6*)        MODEL_NAME="Opus 4.6" ;;
              *opus-4*)          MODEL_NAME="Opus 4" ;;
              *sonnet-4-5*)      MODEL_NAME="Sonnet 4.5" ;;
              *sonnet-4*)        MODEL_NAME="Sonnet 4" ;;
              *haiku-4-5*)       MODEL_NAME="Haiku 4.5" ;;
              *haiku-4*)         MODEL_NAME="Haiku 4" ;;
              *sonnet*3-5*)      MODEL_NAME="Sonnet 3.5" ;;
              *haiku*3-5*)       MODEL_NAME="Haiku 3.5" ;;
              *)                 MODEL_NAME="$MODEL_ID" ;;
            esac
            echo "model=$MODEL_NAME" >> "$GITHUB_OUTPUT"
            echo "Model: $MODEL_NAME"
          fi

      - name: Update review footer with metrics
        id: update-review-metrics
        if: always() && steps.extract-metrics.outputs.duration
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          METRIC_DURATION: ${{ steps.extract-metrics.outputs.duration }}
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost }}
          METRIC_TOKENS: ${{ steps.extract-metrics.outputs.tokens }}
          METRIC_MODEL: ${{ steps.extract-metrics.outputs.model }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const duration = process.env.METRIC_DURATION || '';
            const cost = process.env.METRIC_COST || '';
            const tokens = process.env.METRIC_TOKENS || '';
            const model = process.env.METRIC_MODEL || '';

            // Build metrics string from available values
            const parts = [];
            if (duration) parts.push(duration);
            if (cost) parts.push(cost);
            if (tokens) parts.push(tokens);
            if (model) parts.push(model);

            if (parts.length === 0) {
              console.log('No metrics to inject');
              return;
            }

            const metricsStr = ' Â· ' + parts.join(' Â· ');
            console.log(`Metrics string: ${metricsStr}`);

            // Find the most recent review containing our metrics marker
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              per_page: 100,
            });

            const metricsRegex = /<!-- METRICS[^>]*-->/;
            const claudeReview = reviews
              .filter(r => metricsRegex.test(r.body || ''))
              .pop();

            if (!claudeReview) {
              console.log('No review with metrics marker found');
              return;
            }

            const body = claudeReview.body;

            const updatedBody = body.replace(metricsRegex, metricsStr);

            await github.rest.pulls.updateReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              review_id: claudeReview.id,
              body: updatedBody,
            });

            console.log(`Updated review ${claudeReview.id} with metrics`);

      - name: Clean up tracking comment
        if: always() && steps.progress.outputs.comment_id
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const commentId = ${{ steps.progress.outputs.comment_id }};
            try {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
              });
              console.log(`Deleted progress comment ${commentId}`);
            } catch (error) {
              console.log(`Failed to delete progress comment ${commentId}: ${error.message}`);
            }

      - name: Post error on failure
        if: failure()
        uses: actions/github-script@v7
        env:
          ATTEMPT_OUTCOME: ${{ steps.claude-review-attempt.outcome }}
          RETRY_OUTCOME: ${{ steps.claude-review-retry.outcome }}
          HAS_EXECUTION_FILE: ${{ steps.claude-review-retry.outputs.execution_file || steps.claude-review-attempt.outputs.execution_file || '' }}
          MODEL_TIER: ${{ steps.complexity.outputs.model_tier || 'unknown' }}
          DIFF_LINES: ${{ steps.complexity.outputs.diff_lines || 'unknown' }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const attemptOutcome = process.env.ATTEMPT_OUTCOME;
            const retryOutcome = process.env.RETRY_OUTCOME;
            const hasExecFile = process.env.HAS_EXECUTION_FILE;
            const modelTier = process.env.MODEL_TIER;
            const diffLines = process.env.DIFF_LINES;
            const logsUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            let message;

            if (retryOutcome === 'failure' && !hasExecFile) {
              // Both attempts failed without execution files â€” could be timeout, API error,
              // or action initialization failure. Don't assume the cause.
              message = [
                `âŒ **Claude review failed** after two attempts (no output produced).`,
                ``,
                `This is a ${diffLines}-line PR reviewed with ${modelTier}. Check [workflow logs](${logsUrl}) for error details.`,
                ``,
                `**Options:**`,
                `- Retry with \`@claude\` (transient issues often resolve on retry)`,
                `- Use \`@claude force\` to bypass staleness checks`,
                ``,
                `[Workflow logs](${logsUrl})`,
              ].join('\n');
            } else if (attemptOutcome === 'failure' && retryOutcome === 'failure') {
              // Both failed but had execution files â€” Claude ran but errored
              message = `âŒ Claude review failed on both attempts. [Workflow logs](${logsUrl}) may have details.\n\nTo retry, post a new comment mentioning Claude.`;
            } else {
              // Generic fallback
              message = `âŒ Claude review failed. Check [workflow logs](${logsUrl}) for details.\n\nTo retry, post a new comment mentioning Claude.`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message,
            });

      - name: Post cost warning for expensive reviews
        if: always() && steps.extract-metrics.outputs.cost
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const costStr = (process.env.METRIC_COST || '').replace('$', '');
            const cost = parseFloat(costStr);
            if (isNaN(cost) || cost <= 5.0) return;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ðŸ’° **Review cost alert**: This review cost ${process.env.METRIC_COST}, which is unusually high. Very large PRs tend to produce lower-quality reviews due to diluted focus. Consider breaking this PR into smaller, focused PRs for more effective reviews.`,
            });
            console.log(`Posted cost warning: ${process.env.METRIC_COST}`);

      - name: Report usage metrics
        if: always()
        env:
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
          TRIGGERED_BY: ${{ github.event.comment.user.login }}
          LINEAR_ID: ${{ steps.linear.outputs.linear_id }}
          CUSTOM_INSTRUCTIONS: ${{ steps.instructions.outputs.custom }}
          FORCE_FLAG: ${{ steps.instructions.outputs.force || 'false' }}
          PROGRESS_COMMENT_ID: ${{ steps.progress.outputs.comment_id }}
          METRIC_DURATION: ${{ steps.extract-metrics.outputs.duration || 'N/A' }}
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost || 'N/A' }}
          METRIC_TOKENS: ${{ steps.extract-metrics.outputs.tokens || 'N/A' }}
          METRIC_MODEL: ${{ steps.extract-metrics.outputs.model || 'N/A' }}
          METRIC_CACHE_READ: ${{ steps.extract-metrics.outputs.cache_read || 'N/A' }}
          METRIC_CACHE_CREATION: ${{ steps.extract-metrics.outputs.cache_creation || 'N/A' }}
          MODEL_TIER: ${{ steps.ci-status.outputs.model_tier_override || steps.complexity.outputs.model_tier || 'N/A' }}
          DIFF_LINES: ${{ steps.complexity.outputs.diff_lines || 'N/A' }}
          COMMENT_CAP: ${{ steps.complexity.outputs.comment_cap || 'N/A' }}
        run: |
          echo "### Claude Review Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- PR: #${PR_NUMBER}" >> $GITHUB_STEP_SUMMARY
          echo "- Repository: ${REPO}" >> $GITHUB_STEP_SUMMARY
          echo "- Triggered by: @${TRIGGERED_BY}" >> $GITHUB_STEP_SUMMARY
          echo "- Linear Issue: ${LINEAR_ID:-Not specified}" >> $GITHUB_STEP_SUMMARY
          echo "- Custom Focus: ${CUSTOM_INSTRUCTIONS:-Standard review}" >> $GITHUB_STEP_SUMMARY
          echo "- Force: ${FORCE_FLAG}" >> $GITHUB_STEP_SUMMARY
          echo "- Progress Comment ID: ${PROGRESS_COMMENT_ID:-N/A}" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Complexity Assessment" >> $GITHUB_STEP_SUMMARY
          echo "- Diff lines: ${DIFF_LINES}" >> $GITHUB_STEP_SUMMARY
          echo "- Model tier: ${MODEL_TIER}" >> $GITHUB_STEP_SUMMARY
          echo "- Comment cap: ${COMMENT_CAP}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Execution Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- Duration: ${METRIC_DURATION}" >> $GITHUB_STEP_SUMMARY
          echo "- Cost: ${METRIC_COST}" >> $GITHUB_STEP_SUMMARY
          echo "- Tokens: ${METRIC_TOKENS}" >> $GITHUB_STEP_SUMMARY
          echo "- Cache read: ${METRIC_CACHE_READ}" >> $GITHUB_STEP_SUMMARY
          echo "- Cache creation: ${METRIC_CACHE_CREATION}" >> $GITHUB_STEP_SUMMARY
          echo "- Model: ${METRIC_MODEL}" >> $GITHUB_STEP_SUMMARY
