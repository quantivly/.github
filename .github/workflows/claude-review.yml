name: Claude PR Review

on:
  # Direct trigger for PRs in this (.github) repository
  issue_comment:
    types: [created]

  # Reusable workflow trigger for other repositories in the organization
  workflow_call:
    secrets:
      ANTHROPIC_API_KEY:
        required: true
        description: Anthropic API key for Claude API access
      LINEAR_API_KEY:
        required: false
        description: Linear API key for issue context retrieval
      CLAUDE_APP_PRIVATE_KEY:
        required: false
        description: GitHub App private key for posting reviews as Claude[bot]

# Defensive concurrency: prevents parallel reviews on the same PR.
# Callers should also have their own concurrency block, but this is a safety net.
concurrency:
  group: claude-review-${{ github.repository }}-${{ github.event.issue.number || github.event.number }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  claude-review:
    # Run on workflow_call (caller already filtered) or direct PR comments from humans
    if: |
      github.event_name == 'workflow_call' ||
      (github.event.issue.pull_request &&
       contains(github.event.comment.body, '@claude') &&
       github.event.comment.user.type != 'Bot')

    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Validate commenter permissions
        id: validate
        uses: actions/github-script@v7
        with:
          script: |
            // workflow_call events have no comment payload ‚Äî the caller workflow
            // handles its own filtering, so we trust it and skip permission checks.
            if (context.eventName === 'workflow_call') {
              console.log('Triggered via workflow_call ‚Äî permission check handled by caller');
              return true;
            }

            const commenter = context.payload.comment.user.login;
            const repo = context.repo;

            // Try org membership first
            try {
              await github.rest.orgs.checkMembershipForUser({
                org: repo.owner,
                username: commenter,
              });
              console.log(`‚úì ${commenter} is organization member`);
              return true;
            } catch (orgError) {
              // Check if repo collaborator with write access
              try {
                const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner: repo.owner,
                  repo: repo.repo,
                  username: commenter,
                });
                if (['write', 'admin', 'maintain'].includes(permission.permission)) {
                  console.log(`‚úì ${commenter} is collaborator with ${permission.permission} access`);
                  return true;
                }
              } catch (e) {}
              console.log(`‚úó ${commenter} does not have sufficient permissions`);
              return false;
            }

      - name: Post permission denied
        if: steps.validate.outputs.result == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: '‚ö†Ô∏è Claude reviews are only available to organization members and repository collaborators with write access.'
            });

      - name: Generate GitHub App token
        id: app-token
        if: steps.validate.outputs.result != 'false' && vars.CLAUDE_APP_ID != ''
        uses: actions/create-github-app-token@v2
        continue-on-error: true
        with:
          app-id: ${{ vars.CLAUDE_APP_ID }}
          private-key: ${{ secrets.CLAUDE_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Checkout repository
        if: steps.validate.outputs.result != 'false'
        uses: actions/checkout@v4

      - name: Checkout .github repository for review standards
        if: steps.validate.outputs.result != 'false'
        uses: actions/checkout@v4
        with:
          repository: quantivly/.github
          path: .github-org
          sparse-checkout: |
            docs/review-standards.md
            docs/review-examples.md
          fetch-depth: 1

      - name: Extract Linear issue ID
        id: linear
        if: steps.validate.outputs.result != 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            const match = pr.title.match(/^([A-Z]{2,6}-\d{1,6})/);
            core.setOutput('linear_id', match ? match[1] : '');
            console.log(match ? `Linear issue: ${match[1]}` : 'No Linear issue ID in PR title');

      - name: Extract custom instructions
        id: instructions
        if: steps.validate.outputs.result != 'false'
        uses: actions/github-script@v7
        with:
          script: |
            // workflow_call events have no comment payload
            if (context.eventName === 'workflow_call') {
              core.setOutput('custom', '');
              return;
            }
            const body = context.payload.comment.body;
            const match = body.match(/@claude\b[,:]?\s*(.*)/is);
            if (!match) {
              core.setOutput('custom', '');
              return;
            }
            let instructions = match[1].trim();
            const generic = ['', 'review', 'please review', 'review this', 'please review this', 'review this pr', 'please review this pr'];
            if (generic.includes(instructions.toLowerCase())) {
              core.setOutput('custom', '');
              return;
            }
            // Truncate to prevent prompt stuffing
            if (instructions.length > 2000) {
              instructions = instructions.substring(0, 2000) + '... (truncated)';
            }
            core.setOutput('custom', instructions);

      - name: Fetch previous review context
        id: previous-reviews
        if: steps.validate.outputs.result != 'false'
        uses: actions/github-script@v7
        env:
          APP_SLUG: ${{ steps.app-token.outputs.app-slug }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            // workflow_call events may not have context.issue.number
            if (context.eventName === 'workflow_call') {
              core.setOutput('context', '');
              core.setOutput('count', '0');
              console.log('Triggered via workflow_call ‚Äî skipping previous review fetch');
              return;
            }
            const prNumber = context.issue.number;
            const repo = context.repo;

            // Derive bot login from the GitHub App slug (e.g. "quantivly-reviews" ‚Üí "quantivly-reviews[bot]")
            // Falls back to github-actions[bot] when no App token is available
            const appSlug = process.env.APP_SLUG;
            const botLogin = appSlug ? `${appSlug}[bot]` : 'github-actions[bot]';
            console.log(`Looking for reviews by: ${botLogin}`);

            // Fetch all reviews on this PR
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            // Identify Claude reviews by bot identity
            const claudeReviews = reviews.filter(r => r.user.login === botLogin);

            if (claudeReviews.length === 0) {
              core.setOutput('context', '');
              core.setOutput('count', '0');
              console.log('No previous Claude reviews found');
              return;
            }

            const reviewCount = claudeReviews.length;
            // Find the latest review with a meaningful body for the summary
            // (some reviews are inline-comment-only with empty bodies)
            const latest = claudeReviews.filter(r => (r.body || '').length > 0).pop()
              || claudeReviews[claudeReviews.length - 1];

            // Extract body summary: strip the <sub> footer and cap length
            let bodySummary = (latest.body || '').replace(/<sub>[\s\S]*?<\/sub>/g, '').trim();
            if (bodySummary.length > 800) {
              bodySummary = bodySummary.substring(0, 800) + '...';
            }

            // Fetch inline comments for the latest review
            const { data: allComments } = await github.rest.pulls.listReviewComments({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const reviewComments = allComments
              .filter(c => c.pull_request_review_id === latest.id)
              .map(c => {
                const firstSentence = (c.body || '').split(/[.\n]/)[0].trim();
                const entry = `- \`${c.path}:${c.line || c.original_line || '?'}\` ${firstSentence}`;
                return entry.length > 120 ? entry.substring(0, 117) + '...' : entry;
              });

            // Build context string
            const date = new Date(latest.submitted_at).toISOString().split('T')[0];
            let contextStr = `Previous Claude reviews: ${reviewCount}\n`;
            contextStr += `Latest review: ${date} (${latest.state})\n\n`;
            contextStr += `### Latest Review Summary\n${bodySummary}\n`;

            if (reviewComments.length > 0) {
              contextStr += `\n### Latest Review Inline Findings (${reviewComments.length})\n`;
              contextStr += reviewComments.join('\n');
            }

            // Hard cap at 4000 chars to control token budget
            if (contextStr.length > 4000) {
              contextStr = contextStr.substring(0, 3997) + '...';
            }

            core.setOutput('context', contextStr);
            core.setOutput('count', String(reviewCount));
            // Output the commit SHA the latest review was submitted on (for staleness detection)
            core.setOutput('last_review_commit', latest.commit_id || '');
            // Output the latest review state (APPROVED, CHANGES_REQUESTED, COMMENTED, DISMISSED)
            core.setOutput('last_review_state', latest.state || '');
            console.log(`Found ${reviewCount} previous Claude review(s). Context: ${contextStr.length} chars`);
            console.log(`Latest review commit: ${latest.commit_id || 'unknown'}, state: ${latest.state || 'unknown'}`);

      - name: Check for stale re-reviews
        id: staleness
        if: steps.validate.outputs.result != 'false' && steps.previous-reviews.outputs.count >= 2
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const repo = context.repo;
            const lastReviewCommit = '${{ steps.previous-reviews.outputs.last_review_commit }}';
            const lastReviewState = '${{ steps.previous-reviews.outputs.last_review_state }}';
            const reviewCount = parseInt('${{ steps.previous-reviews.outputs.count }}', 10);

            if (!lastReviewCommit) {
              console.log('No commit SHA from last review ‚Äî cannot detect staleness');
              core.setOutput('skip', 'false');
              return;
            }

            // Get the PR's current head SHA
            const { data: pr } = await github.rest.pulls.get({
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
            });
            const currentHead = pr.head.sha;
            console.log(`Current HEAD: ${currentHead}, Last review commit: ${lastReviewCommit}, State: ${lastReviewState}`);

            if (currentHead === lastReviewCommit) {
              // Skip if already approved on this commit (no point re-reviewing)
              if (lastReviewState === 'APPROVED') {
                console.log('Stale: last review was APPROVE on this commit ‚Äî no re-review needed');
              } else {
                console.log(`Stale: ${reviewCount} prior reviews and no code changes since last review`);
              }
              core.setOutput('skip', 'true');
            } else {
              console.log('Code has changed since last review ‚Äî proceeding');
              core.setOutput('skip', 'false');
            }

      - name: Post stale review notice
        if: steps.staleness.outputs.skip == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const count = '${{ steps.previous-reviews.outputs.count }}';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `üîÑ **Skipping review** ‚Äî no code changes since the last review (${count} prior reviews on the same commit). Previous review findings still apply.\n\nPush new commits and then trigger \`@claude\` again for a fresh review.`,
            });

      - name: Compute diff since last review
        id: delta
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true' && steps.previous-reviews.outputs.last_review_commit != ''
        continue-on-error: true
        env:
          LAST_REVIEW_COMMIT: ${{ steps.previous-reviews.outputs.last_review_commit }}
        run: |
          # Compute what changed since the last review for focused re-review
          DELTA=$(git diff "$LAST_REVIEW_COMMIT"..HEAD --stat 2>/dev/null || echo "Unable to compute delta ‚Äî commit may have been force-pushed")
          {
            echo "delta<<DELTA_EOF"
            echo "$DELTA" | head -50
            echo "DELTA_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create MCP config for Linear
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
        run: |
          # Create .mcp.json with explicit auth headers for Linear MCP server
          # GitHub Actions needs explicit Bearer auth in .mcp.json
          # (locally, Claude Code auto-injects auth from env vars)
          if [ -n "$LINEAR_API_KEY" ]; then
            printf '{"mcpServers":{"linear":{"type":"http","url":"https://mcp.linear.app/mcp","headers":{"Authorization":"Bearer %s"}}}}' "$LINEAR_API_KEY" > .mcp.json
            echo "Created .mcp.json with Linear MCP server auth configuration"
          else
            echo "LINEAR_API_KEY not set, skipping MCP config"
          fi

      - name: Assess PR complexity
        id: complexity
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            const repo = context.repo;

            // Paginate to handle PRs with 100+ files (GitHub returns max 100 per page)
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: repo.owner,
              repo: repo.repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const totalAdditions = files.reduce((sum, f) => sum + f.additions, 0);
            const totalDeletions = files.reduce((sum, f) => sum + f.deletions, 0);
            const diffLines = totalAdditions + totalDeletions;
            const fileCount = files.length;
            const filenames = files.map(f => f.filename);

            console.log(`PR stats: ${diffLines} diff lines across ${fileCount} files`);

            // Check if PR is docs/config-only
            const docsConfigExtensions = /\.(md|yml|yaml|json|txt|toml|cfg|ini|env\.example)$/;
            const isDocsConfigOnly = filenames.every(f => docsConfigExtensions.test(f));

            // Check if docs/config includes infrastructure YAML (workflows, Docker, k8s)
            // These contain security-sensitive configuration and should not be reviewed with Haiku
            const infraPatterns = /(workflow|docker|k8s|helm|deploy|infra|compose)/i;
            const hasInfraYaml = filenames.some(f =>
              /\.(yml|yaml)$/.test(f) && infraPatterns.test(f)
            );

            // Check if PR touches security-sensitive paths
            // Note: 'access' was removed (too broad ‚Äî matches accessibility.py, data_access_layer.py)
            const securityPaths = /(auth|security|login|password|token|session|permission|crypto|encrypt|hipaa|phi|middleware|migration|webhook|oauth|saml|keycloak|audit|secret|credential)/i;
            const securityFileCount = filenames.filter(f => securityPaths.test(f)).length;

            // Scan diff patches for PHI-related keywords (catches PHI handling regardless of filename)
            const phiKeywords = /(patient|mrn|medical_record|ssn|social_security|date_of_birth|dob|diagnosis|phi_|hipaa)/i;
            const diffContainsPhi = files.some(f => phiKeywords.test(f.patch || ''));
            if (diffContainsPhi) {
              console.log('PHI-related keywords detected in diff content ‚Äî escalating to opus');
            }

            // Weighted complexity score: new code needs more scrutiny than deleted code,
            // and security-sensitive files escalate regardless of diff size
            const complexityScore = (totalAdditions * 1.0) + (totalDeletions * 0.3) + (securityFileCount * 200);

            // Model selection: docs/config ‚Üí haiku, complex/security/PHI ‚Üí opus, default ‚Üí sonnet
            // Model IDs are mapped here so claude_args can use --model directly
            const modelMap = {
              haiku: 'claude-haiku-4-5-20251001',
              sonnet: 'claude-sonnet-4-5-20250929',
              opus: 'claude-opus-4-6',
            };
            let modelTier = 'sonnet';
            if (isDocsConfigOnly && !hasInfraYaml) {
              modelTier = 'haiku';
            } else if (isDocsConfigOnly && hasInfraYaml) {
              modelTier = 'sonnet';
            } else if (complexityScore > 500 || diffContainsPhi) {
              modelTier = 'opus';
            }
            const model = modelMap[modelTier];

            // Adaptive comment cap: scale with diff size, min 3, max 12
            const commentCap = Math.max(3, Math.min(12, Math.ceil(diffLines / 50)));

            console.log(`Model: ${modelTier} (${model}), Comment cap: ${commentCap}`);
            core.setOutput('model', model);
            core.setOutput('model_tier', modelTier);
            core.setOutput('comment_cap', String(commentCap));
            core.setOutput('diff_lines', String(diffLines));

      - name: Post progress comment
        id: progress
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        uses: actions/github-script@v7
        env:
          MODEL_TIER: ${{ steps.complexity.outputs.model_tier }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const tier = process.env.MODEL_TIER || 'sonnet';
            const tierInfo = {
              haiku: { name: 'Haiku 4.5', time: '~1-2 minutes', desc: 'docs/config review' },
              sonnet: { name: 'Sonnet 4.5', time: '~2-4 minutes', desc: 'standard code review' },
              opus: { name: 'Opus 4.6', time: '~3-7 minutes', desc: 'large/security-sensitive review' },
            };
            const info = tierInfo[tier] || tierInfo.sonnet;
            const body = `ü§ñ **Claude review started...** Using ${info.name} (${info.desc}). Expected: ${info.time}.\n\n_Analyzing code for security, logic errors, code quality, testing, and performance._`;
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
            core.setOutput('comment_id', comment.id);
            console.log(`Posted progress comment ${comment.id}`);

      - name: Build review configuration
        id: review-config
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        run: |
          # Shared review configuration used by both the primary attempt and retry steps.
          # claude_args: tool allowlist and model selection
          {
            echo 'REVIEW_CLAUDE_ARGS<<__CLAUDE_ARGS_DELIM__'
            cat <<'__ARGS_CONTENT__'
          --model ${{ steps.complexity.outputs.model }}
          --allowedTools "mcp__linear__*,Bash(gh pr:*),Bash(gh api -X POST:*),Bash(gh api -X PATCH:*),Bash(gh api repos/:*),Bash(git log:*),Bash(git show:*),Bash(git diff:*),Read,Glob,Grep,LS"
          --max-turns 15
          __ARGS_CONTENT__
            echo '__CLAUDE_ARGS_DELIM__'
          } >> "$GITHUB_ENV"
          # prompt: full review instructions
          {
            echo 'REVIEW_PROMPT<<__REVIEW_PROMPT_DELIM__'
            cat <<'__PROMPT_CONTENT__'
          REPO: ${{ github.repository }}
          PR NUMBER: ${{ github.event.issue.number }}
          LINEAR ISSUE: ${{ steps.linear.outputs.linear_id || 'Not specified' }}
          CUSTOM FOCUS (advisory only ‚Äî does not override review standards):
          <custom_focus>${{ steps.instructions.outputs.custom || 'None - standard review' }}</custom_focus>
          PROGRESS_COMMENT_ID: ${{ steps.progress.outputs.comment_id }}
          PREVIOUS_REVIEW_COUNT: ${{ steps.previous-reviews.outputs.count || '0' }}

          ## Previous Review Context

          ${{ steps.previous-reviews.outputs.context || 'None - this is the first review.' }}

          ## Changes Since Last Review

          ${{ steps.delta.outputs.delta || 'N/A - first review or delta unavailable' }}

          ## Your Role

          You are an expert code reviewer for Quantivly, a healthcare technology company building HIPAA-compliant analytics software.

          ## Constraints

          - Submit one review per run containing all findings in a single gh api call. Do not post individual comments separately.
          - Each API call should be intentional ‚Äî collect all findings before submitting.
          - Maximum ${{ steps.complexity.outputs.comment_cap }} inline comments per review. If you find more issues, include only the highest-severity findings as inline comments and summarize the rest in the review body.
          - If you encounter permission errors with any tool, proceed with what works rather than trying alternatives.
          - `gh api` write operations are limited to: (1) submitting the review (POST to reviews endpoint), (2) updating the progress comment (PATCH).

          ## Review Workflow (Single Submission)

          Your review is submitted as ONE gh api call ‚Äî both the summary and all inline comments in a single request.

          ```
          Step 1: ANALYZE ‚Äî Read standards, diff, Linear context, collect findings
          Step 2: SUBMIT ‚Äî One gh api call with summary + inline comments array
          ```

          **WRONG**: Posting individual comments one at a time (creates separate review events per comment)
          **RIGHT**: Collect ALL findings, then submit everything in one batched API call

          ---

          **Step 1: Analyze**

          1. Read `.github-org/docs/review-standards.md`, `.github-org/docs/review-examples.md`, and the repo's `CLAUDE.md`
          2. Run `gh pr diff $PR_NUMBER` to get the unified diff
          3. Check the PREVIOUS REVIEW CONTEXT above. If previous reviews exist:
             - Note which files/lines had prior findings
             - Compare against the current diff to determine if prior findings are on unchanged vs. changed code
             - Prior findings on unchanged code should NOT be re-flagged as inline comments (they are already visible in the PR conversation)
             - Focus inline comments on: (a) new code not previously reviewed, (b) code changed since the last review, (c) prior findings addressed incorrectly or incompletely
          4. Analyze the diff for security, logic, quality, testing, performance issues. Before flagging any issue, use `Read` to see the full file context around the location ‚Äî do not flag issues based solely on diff snippets.
          5. If Linear issue provided, fetch requirements and validate alignment
          6. For each finding, note: file path, line number (from the new version of the file), severity, description

          ---

          **Step 2: Submit Review (Single API Call)**

          Submit ALL findings in one call using this exact structure:

          ```
          gh api -X POST "repos/${{ github.repository }}/pulls/${{ github.event.issue.number }}/reviews" --input - <<'REVIEW_JSON'
          {
            "event": "<EVENT>",
            "body": "<REVIEW_SUMMARY>",
            "comments": [
              {
                "path": "src/auth/login.py",
                "line": 42,
                "side": "RIGHT",
                "body": "‚ö†Ô∏è **Missing request timeout**\n\n`requests.get(url)` has no timeout ‚Äî blocks the thread indefinitely if the server is unreachable.\n\n```suggestion\nresponse = requests.get(url, timeout=10)\n```"
              },
              {
                "path": "apps/dashboard/resolvers.py",
                "start_line": 45,
                "line": 48,
                "start_side": "RIGHT",
                "side": "RIGHT",
                "body": "‚ö†Ô∏è **N+1 query in list comprehension**\n\n`facility.equipment_set.all()` inside the loop triggers a separate query per facility.\n\n```suggestion\nfacilities = Facility.objects.filter(\n    organization=org\n).prefetch_related('equipment_set')\n```"
              },
              {
                "path": "apps/export/views.py",
                "line": 25,
                "side": "RIGHT",
                "body": "üí° **Consider streaming for large exports**\n\nThe view loads all rows into memory before writing the CSV response. For datasets exceeding 10k rows, consider using `StreamingHttpResponse` with a generator to keep memory bounded:\n```python\ndef rows():\n    for study in queryset.iterator():\n        yield writer.writerow([study.id, study.name])\n```"
              }
            ]
          }
          REVIEW_JSON
          ```

          Rules for the JSON:
          - `line` is the line number in the new file version (integer)
          - `path` is relative to repo root (e.g., "src/auth/login.py")
          - `body` values must be valid JSON strings: escape `"` as `\"`, newlines as `\n`, backslashes as `\\`
          - `side` is always `"RIGHT"` for commenting on added/modified code
          - General observations that don't apply to a specific line go in the review `body`, not in `comments`
          - Inline comments must be about specific code at the referenced line (logic flaws, security vulnerabilities, bugs, improvements). Project-level observations ‚Äî Linear issue status, PR scope/direction, overall test coverage gaps, architectural concerns ‚Äî belong in the review `body` regardless of severity. If no code-specific findings exist, the `comments` array should be empty.
          - When the fix is a direct replacement of the commented line(s), use a suggestion block: ```suggestion\n<replacement code>\n``` ‚Äî the developer can one-click apply or batch commit multiple suggestions
          - When the fix involves changes elsewhere or structural changes, use a regular code block (```python) instead of a suggestion block
          - For multi-line suggestions: use `start_line`, `start_side`: `RIGHT`, `line`, `side`: `RIGHT` ‚Äî the suggestion replaces lines from `start_line` through `line`
          - A suggestion block replaces the targeted line(s) exactly ‚Äî the code inside must be complete and correct for those specific lines (no `...` elision, no imports that would replace business logic)
          - Suggestion blocks only work on lines that are part of the PR diff
          - Each comment body may contain at most one suggestion block

          Choose event based on findings:
          - `REQUEST_CHANGES`: Has CRITICAL issues
          - `COMMENT`: Has HIGH issues or needs clarification
          - `APPROVE`: Only suggestions, no blockers

          ---

          **If the review submission fails (e.g., 422 from invalid line number):**

          Retry without the `comments` array ‚Äî put all findings in the body as formatted text:
          ```
          gh api -X POST "repos/${{ github.repository }}/pulls/${{ github.event.issue.number }}/reviews" \
            -f event="<EVENT>" \
            -f body="<FULL_REVIEW_WITH_ALL_FINDINGS>"
          ```

          ## Tool Usage Rules

          **For submitting the review (with inline comments):**
          - `gh api -X POST repos/.../pulls/.../reviews --input -` with JSON containing event, body, and comments array
          - This is the ONLY review submission ‚Äî one call, all findings included

          **For reading data:**
          - `gh api` (GET) ‚Äî read files from other repos, fetch PR metadata
          - `gh pr` ‚Äî read PR details (title, description, files)
          - `Read` tool ‚Äî read local files (e.g., `Read("CLAUDE.md")`). Prefer Read over Bash for file reading.

          **For progress updates:**
          - `gh api -X PATCH repos/.../issues/comments/...` ‚Äî update the progress comment

          ## Quality Filter (Apply to Every Finding)

          For every potential finding, ask: "Am I confident this is a real issue, not a false positive caused by missing context?" If uncertain, include it as a brief note in the review body rather than as an inline comment. Inline comments should be reserved for findings you are confident about.

          A review with 2 high-confidence findings is more valuable than one with 8 uncertain ones. Developers stop reading reviews they don't trust.

          **Verify before flagging**: Read the full file context around each location before including it. Diff snippets can be misleading ‚Äî a function that looks problematic in the diff may be correct in its surrounding context.

          **Actionable findings**: Every inline comment must include a concrete fix. Prefer suggestion blocks for one-click apply:
          - Best: suggestion block ‚Äî "‚ö†Ô∏è **SQL injection** ... ```suggestion\ncursor.execute('SELECT * FROM users WHERE id = %s', (user_id,))\n```" (one-click apply)
          - Good: regular code block ‚Äî when the fix doesn't directly replace the commented line(s)
          - Bad: "‚ö†Ô∏è This query might have a SQL injection issue" (vague, no fix)

          **Common false positives to skip**:
          - Django `Meta` classes don't need docstrings
          - `# type: ignore` comments ‚Äî verify the suppression context before flagging
          - Test fixtures appearing as "unused variables" (pytest injects them)
          - Django settings files with uppercase naming conventions (these are constants by design)
          - `noqa` comments ‚Äî these are intentional lint suppressions, not code smells

          **Third-party integrations**: If the PR adds a new third-party API integration (new SDK import, new HTTP client call to a non-Quantivly domain), flag it as a HIGH finding for BAA (Business Associate Agreement) review, since HIPAA requires BAAs for any third party handling PHI.

          ## Review Standards

          Read `.github-org/docs/review-standards.md` for severity levels, checklists, silent failure patterns, testing assessment criteria, PR-type triage, cross-repo validation, and Quantivly's repository architecture.
          Read `.github-org/docs/review-examples.md` for concrete examples of well-calibrated reviews at different severity levels.
          Also read the repository's `CLAUDE.md` if it exists.

          ## Linear Integration

          If a Linear issue ID is provided, use the Linear MCP tools to:
          1. Fetch the issue description and acceptance criteria
          2. Review any comments for additional requirements
          3. Validate the PR implementation aligns with requirements
          4. Flag any gaps between requirements and implementation

          ## Before Submitting

          Before submitting, verify each inline comment passes ALL of these:
          1. I read the full file (not just the diff) around this location
          2. I can explain what specific bug, vulnerability, or issue exists
          3. My fix suggestion compiles/runs correctly in this codebase's context
          4. This is NOT something pre-commit hooks (ruff, black, mypy) would catch
          5. For each suggestion block: the replacement code exactly replaces the targeted line(s) and would be valid code if applied
          6. Multi-line suggestions use both `start_line`/`start_side` and `line`/`side`

          If uncertain about a finding, move it to the summary body rather than keeping it as an inline comment. Check that inline comments reference correct line numbers and include actionable fix suggestions.

          ## Output Format

          Your review summary (the `body` parameter when submitting the review) must be under 250 words. Use inline comments for code-specific details ‚Äî the body is only for the structured summary below:

          ---

          > [1-2 sentences: what the PR does]

          **Linear**: [Issue-ID](https://linear.app/quantivly/issue/Issue-ID/) ‚Äî [Status: ‚úÖ Aligned / ‚ö†Ô∏è Gaps / ‚ùå Misaligned]. If no Linear issue is found, use "Not specified" instead of the link.

          **Re-review**: [If PREVIOUS_REVIEW_COUNT > 0: "Re-review #(PREVIOUS_REVIEW_COUNT + 1). X of Y prior findings addressed. Focusing on new/changed code." If PREVIOUS_REVIEW_COUNT is 0: omit this line entirely.]

          **Issues**: üö® X ¬∑ ‚ö†Ô∏è Y ¬∑ üí° Z ‚Äî see inline comments

          [If any findings were omitted because they exceeded the inline comment cap, add a collapsible block:]
          <details>
          <summary>üìã N additional findings omitted (comment cap)</summary>

          - `file.py:42` ‚Äî Description of omitted finding
          - ...

          </details>

          **Highlights**:
          - ‚úÖ [Notable good practice]
          - ‚úÖ [Another positive]

          ---
          <sub>@${{ github.event.comment.user.login }}<!-- METRICS --> ¬∑ [Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) ¬∑ üëç üëé</sub>

          ---

          Keep the summary short. All code-specific findings (CRITICAL, HIGH, Suggestion) go in the `comments` array ‚Äî each referencing a specific line and directly relevant to the code at that line. Project-level findings (Linear misalignment, PR scope issues, missing test files, architectural direction) belong in the review `body` only, even at CRITICAL severity. If the only findings are project-level, submit with an empty `comments` array.
          If previous reviews exist (PREVIOUS_REVIEW_COUNT > 0), prioritize new findings. Acknowledge addressed issues briefly in the summary. Only re-flag a prior finding as an inline comment if the fix attempt introduced a new problem.
          On re-reviews where no code has changed since the last review, do not re-flag the same findings as new inline comments. If the only observation is a previously-reported project-level issue (e.g., Linear misalignment already noted in a prior review), submit a brief body-only COMMENT review stating there are no new code findings, rather than attaching repeated observations to arbitrary lines.
          Format each inline comment as: `<emoji> **<Short Title>**` followed by explanation and fix.
          - üö® for security and data loss issues (must fix)
          - ‚ö†Ô∏è for bugs and logic errors (should fix)
          - üí° for improvements (nice to have)

          With suggestion block (direct line replacement):
          "‚ö†Ô∏è **Missing request timeout**\n\n`requests.get(url)` has no timeout.\n\n```suggestion\nresponse = requests.get(url, timeout=10)\n```"

          With regular code block (fix is elsewhere or structural):
          "üí° **Consider streaming for large exports**\n\nLoads all rows into memory. Use a generator:\n```python\ndef rows():\n    for study in queryset.iterator():\n        yield writer.writerow([study.id, study.name])\n```"

          ## Progress Updates (Optional, Non-Blocking)

          A progress comment has been posted on the PR. Update it at each milestone using:
          ```
          gh api -X PATCH repos/<REPO>/issues/comments/<PROGRESS_COMMENT_ID> -f body='<updated body>'
          ```

          Substitute the actual REPO and PROGRESS_COMMENT_ID values from the context variables above.

          Update at these milestones (use the exact bodies below):

          **After reading review standards / CLAUDE.md:**
          ```
          ü§ñ **Claude review in progress...**

          ‚úÖ Read review standards and repository context
          ‚è≥ Analyzing code changes...
          ```

          **After analyzing the diff, before posting inline comments:**
          ```
          ü§ñ **Claude review in progress...**

          ‚úÖ Read review standards and repository context
          ‚úÖ Analyzed code changes
          ‚è≥ Composing review...
          ```

          Rules:
          - If an update fails, ignore the error and continue with the review. Progress updates are nice-to-have.
          - Do NOT update more than twice. Do NOT update after submitting the review (cleanup is handled automatically).
          __PROMPT_CONTENT__
            echo '__REVIEW_PROMPT_DELIM__'
          } >> "$GITHUB_ENV"

      - name: Run Claude PR Review
        id: claude-review-attempt
        if: steps.validate.outputs.result != 'false' && steps.staleness.outputs.skip != 'true'
        continue-on-error: true
        timeout-minutes: 12
        uses: anthropics/claude-code-action@b113f49a56229d8276e2bf05743ad6900121239c # v1
        env:
          # Linear MCP server (via .mcp.json) uses env var for API authentication
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          # gh CLI reads from GH_TOKEN env var (using GH_ prefix since GitHub reserves GITHUB_)
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          # Enable MCP servers from .mcp.json (created by the "Create MCP config" step above).
          # Since the workflow generates .mcp.json with only the Linear server, this is
          # effectively scoped to Linear ‚Äî repo-level .mcp.json files are overwritten.
          settings: '{"enableAllProjectMcpServers": true}'
          # Allow tools for PR review:
          # - Linear MCP tools (issue context, requirements) via .mcp.json server
          # - gh CLI for: reading PR data, cross-repo files, submitting batched review, progress updates
          # - File tools for reading codebase
          # - git for commit history context
          # Review submission uses gh api POST to /reviews with comments array (single review event)
          # gh api scoped to: POST reviews, PATCH progress comments, GET cross-repo files
          claude_args: ${{ env.REVIEW_CLAUDE_ARGS }}
          prompt: ${{ env.REVIEW_PROMPT }}

      - name: Update progress comment for retry
        if: steps.claude-review-attempt.outcome == 'failure' && !steps.claude-review-attempt.outputs.execution_file
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const commentId = '${{ steps.progress.outputs.comment_id }}';
            if (!commentId) return;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body: 'ü§ñ **Claude review retrying...**\n\n‚ö†Ô∏è First attempt did not complete successfully. Retrying automatically...',
            });

      - name: Run Claude PR Review (retry)
        id: claude-review-retry
        if: steps.claude-review-attempt.outcome == 'failure' && !steps.claude-review-attempt.outputs.execution_file
        timeout-minutes: 12
        uses: anthropics/claude-code-action@b113f49a56229d8276e2bf05743ad6900121239c # v1
        env:
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          GH_TOKEN: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          settings: '{"enableAllProjectMcpServers": true}'
          claude_args: ${{ env.REVIEW_CLAUDE_ARGS }}
          prompt: ${{ env.REVIEW_PROMPT }}

      - name: Extract execution metrics
        id: extract-metrics
        if: always() && (steps.claude-review-retry.outputs.execution_file || steps.claude-review-attempt.outputs.execution_file)
        continue-on-error: true
        env:
          EXECUTION_FILE: ${{ steps.claude-review-retry.outputs.execution_file || steps.claude-review-attempt.outputs.execution_file }}
        run: |
          if [ ! -f "$EXECUTION_FILE" ]; then
            echo "Execution file not found: $EXECUTION_FILE"
            exit 0
          fi

          # Cost: from the result turn's total_cost_usd (pre-computed by the SDK)
          COST=$(jq -r '
            [.[] | select(.type == "result")] | last //empty |
            (.total_cost_usd // .cost_usd // empty)
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$COST" ] && [ "$COST" != "null" ]; then
            COST_FMT=$(printf '$%.2f' "$COST")
            echo "cost=$COST_FMT" >> "$GITHUB_OUTPUT"
            echo "Cost: $COST_FMT"
          fi

          # Duration: from the result turn's duration_ms (pre-computed by the SDK)
          DURATION_MS=$(jq -r '
            [.[] | select(.type == "result")] | last //empty |
            .duration_ms // empty
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$DURATION_MS" ] && [ "$DURATION_MS" != "null" ]; then
            TOTAL_SEC=$(( DURATION_MS / 1000 ))
            if [ "$TOTAL_SEC" -ge 60 ]; then
              MINS=$(( TOTAL_SEC / 60 ))
              SECS=$(( TOTAL_SEC % 60 ))
              DURATION_FMT="${MINS}m ${SECS}s"
            else
              DURATION_FMT="${TOTAL_SEC}s"
            fi
            echo "duration=$DURATION_FMT" >> "$GITHUB_OUTPUT"
            echo "Duration: $DURATION_FMT"
          fi

          # Tokens: sum usage across all assistant turns
          TOKENS=$(jq '
            [.[] | select(.type == "assistant") | .message.usage // empty |
              ((.input_tokens // 0) + (.output_tokens // 0) +
               (.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0))
            ] | add // 0
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$TOKENS" ] && [ "$TOKENS" != "null" ] && [ "$TOKENS" -gt 0 ] 2>/dev/null; then
            if [ "$TOKENS" -ge 1000000 ]; then
              # e.g. 1234567 -> "1.2M tokens"
              TOKENS_FMT="$(echo "$TOKENS" | awk '{printf "%.1fM", $1/1000000}') tokens"
            elif [ "$TOKENS" -ge 1000 ]; then
              # e.g. 42300 -> "42k tokens"
              TOKENS_FMT="$(echo "$TOKENS" | awk '{printf "%.0fk", $1/1000}') tokens"
            else
              TOKENS_FMT="${TOKENS} tokens"
            fi
            echo "tokens=$TOKENS_FMT" >> "$GITHUB_OUTPUT"
            echo "Tokens: $TOKENS_FMT"
          fi

          # Cache: separate cache read vs creation tokens
          CACHE_READ=$(jq '
            [.[] | select(.type == "assistant") | .message.usage // empty |
              (.cache_read_input_tokens // 0)
            ] | add // 0
          ' "$EXECUTION_FILE" 2>/dev/null)
          CACHE_CREATION=$(jq '
            [.[] | select(.type == "assistant") | .message.usage // empty |
              (.cache_creation_input_tokens // 0)
            ] | add // 0
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$CACHE_READ" ] && [ "$CACHE_READ" != "null" ] && [ "$CACHE_READ" -gt 0 ] 2>/dev/null; then
            if [ "$CACHE_READ" -ge 1000 ]; then
              CACHE_READ_FMT="$(echo "$CACHE_READ" | awk '{printf "%.0fk", $1/1000}')"
            else
              CACHE_READ_FMT="$CACHE_READ"
            fi
            echo "cache_read=${CACHE_READ_FMT} cached" >> "$GITHUB_OUTPUT"
            echo "Cache read: ${CACHE_READ_FMT}"
          fi
          if [ -n "$CACHE_CREATION" ] && [ "$CACHE_CREATION" != "null" ] && [ "$CACHE_CREATION" -gt 0 ] 2>/dev/null; then
            if [ "$CACHE_CREATION" -ge 1000 ]; then
              CACHE_CREATION_FMT="$(echo "$CACHE_CREATION" | awk '{printf "%.0fk", $1/1000}')"
            else
              CACHE_CREATION_FMT="$CACHE_CREATION"
            fi
            echo "cache_creation=${CACHE_CREATION_FMT} new cache" >> "$GITHUB_OUTPUT"
            echo "Cache creation: ${CACHE_CREATION_FMT}"
          fi

          # Model: from the system init message
          MODEL_ID=$(jq -r '
            [.[] | select(.type == "system" and .subtype == "init")] | first //empty |
            .model // empty
          ' "$EXECUTION_FILE" 2>/dev/null)
          if [ -n "$MODEL_ID" ] && [ "$MODEL_ID" != "null" ]; then
            # Map model IDs to human-readable names
            case "$MODEL_ID" in
              *opus-4-6*)        MODEL_NAME="Opus 4.6" ;;
              *opus-4*)          MODEL_NAME="Opus 4" ;;
              *sonnet-4-5*)      MODEL_NAME="Sonnet 4.5" ;;
              *sonnet-4*)        MODEL_NAME="Sonnet 4" ;;
              *haiku-4-5*)       MODEL_NAME="Haiku 4.5" ;;
              *haiku-4*)         MODEL_NAME="Haiku 4" ;;
              *sonnet*3-5*)      MODEL_NAME="Sonnet 3.5" ;;
              *haiku*3-5*)       MODEL_NAME="Haiku 3.5" ;;
              *)                 MODEL_NAME="$MODEL_ID" ;;
            esac
            echo "model=$MODEL_NAME" >> "$GITHUB_OUTPUT"
            echo "Model: $MODEL_NAME"
          fi

      - name: Update review footer with metrics
        id: update-review-metrics
        if: always() && steps.extract-metrics.outputs.duration
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          METRIC_DURATION: ${{ steps.extract-metrics.outputs.duration }}
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost }}
          METRIC_TOKENS: ${{ steps.extract-metrics.outputs.tokens }}
          METRIC_MODEL: ${{ steps.extract-metrics.outputs.model }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const duration = process.env.METRIC_DURATION || '';
            const cost = process.env.METRIC_COST || '';
            const tokens = process.env.METRIC_TOKENS || '';
            const model = process.env.METRIC_MODEL || '';

            // Build metrics string from available values
            const parts = [];
            if (duration) parts.push(duration);
            if (cost) parts.push(cost);
            if (tokens) parts.push(tokens);
            if (model) parts.push(model);

            if (parts.length === 0) {
              console.log('No metrics to inject');
              return;
            }

            const metricsStr = ' ¬∑ ' + parts.join(' ¬∑ ');
            console.log(`Metrics string: ${metricsStr}`);

            // Find the most recent review containing our metrics marker
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              per_page: 100,
            });

            const claudeReview = reviews
              .filter(r => (r.body || '').includes('<!-- METRICS -->'))
              .pop();

            if (!claudeReview) {
              console.log('No review with metrics marker found');
              return;
            }

            const body = claudeReview.body;

            const updatedBody = body.replace('<!-- METRICS -->', metricsStr);

            await github.rest.pulls.updateReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              review_id: claudeReview.id,
              body: updatedBody,
            });

            console.log(`Updated review ${claudeReview.id} with metrics`);

      - name: Clean up tracking comment
        if: always() && steps.progress.outputs.comment_id
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const commentId = ${{ steps.progress.outputs.comment_id }};
            try {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: commentId,
              });
              console.log(`Deleted progress comment ${commentId}`);
            } catch (error) {
              console.log(`Failed to delete progress comment ${commentId}: ${error.message}`);
            }

      - name: Post error on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚ùå Claude review failed. Check [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\nTo retry, post a new comment mentioning Claude.`
            });

      - name: Post cost warning for expensive reviews
        if: always() && steps.extract-metrics.outputs.cost
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost }}
        with:
          github-token: ${{ steps.app-token.outputs.token || secrets.GITHUB_TOKEN }}
          script: |
            const costStr = (process.env.METRIC_COST || '').replace('$', '');
            const cost = parseFloat(costStr);
            if (isNaN(cost) || cost <= 5.0) return;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `üí∞ **Review cost alert**: This review cost ${process.env.METRIC_COST}, which is unusually high. Very large PRs tend to produce lower-quality reviews due to diluted focus. Consider breaking this PR into smaller, focused PRs for more effective reviews.`,
            });
            console.log(`Posted cost warning: ${process.env.METRIC_COST}`);

      - name: Report usage metrics
        if: always()
        env:
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
          TRIGGERED_BY: ${{ github.event.comment.user.login }}
          LINEAR_ID: ${{ steps.linear.outputs.linear_id }}
          CUSTOM_INSTRUCTIONS: ${{ steps.instructions.outputs.custom }}
          PROGRESS_COMMENT_ID: ${{ steps.progress.outputs.comment_id }}
          METRIC_DURATION: ${{ steps.extract-metrics.outputs.duration || 'N/A' }}
          METRIC_COST: ${{ steps.extract-metrics.outputs.cost || 'N/A' }}
          METRIC_TOKENS: ${{ steps.extract-metrics.outputs.tokens || 'N/A' }}
          METRIC_MODEL: ${{ steps.extract-metrics.outputs.model || 'N/A' }}
          METRIC_CACHE_READ: ${{ steps.extract-metrics.outputs.cache_read || 'N/A' }}
          METRIC_CACHE_CREATION: ${{ steps.extract-metrics.outputs.cache_creation || 'N/A' }}
          MODEL_TIER: ${{ steps.complexity.outputs.model_tier || 'N/A' }}
          DIFF_LINES: ${{ steps.complexity.outputs.diff_lines || 'N/A' }}
          COMMENT_CAP: ${{ steps.complexity.outputs.comment_cap || 'N/A' }}
        run: |
          echo "### Claude Review Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- PR: #${PR_NUMBER}" >> $GITHUB_STEP_SUMMARY
          echo "- Repository: ${REPO}" >> $GITHUB_STEP_SUMMARY
          echo "- Triggered by: @${TRIGGERED_BY}" >> $GITHUB_STEP_SUMMARY
          echo "- Linear Issue: ${LINEAR_ID:-Not specified}" >> $GITHUB_STEP_SUMMARY
          echo "- Custom Focus: ${CUSTOM_INSTRUCTIONS:-Standard review}" >> $GITHUB_STEP_SUMMARY
          echo "- Progress Comment ID: ${PROGRESS_COMMENT_ID:-N/A}" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Complexity Assessment" >> $GITHUB_STEP_SUMMARY
          echo "- Diff lines: ${DIFF_LINES}" >> $GITHUB_STEP_SUMMARY
          echo "- Model tier: ${MODEL_TIER}" >> $GITHUB_STEP_SUMMARY
          echo "- Comment cap: ${COMMENT_CAP}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Execution Metrics" >> $GITHUB_STEP_SUMMARY
          echo "- Duration: ${METRIC_DURATION}" >> $GITHUB_STEP_SUMMARY
          echo "- Cost: ${METRIC_COST}" >> $GITHUB_STEP_SUMMARY
          echo "- Tokens: ${METRIC_TOKENS}" >> $GITHUB_STEP_SUMMARY
          echo "- Cache read: ${METRIC_CACHE_READ}" >> $GITHUB_STEP_SUMMARY
          echo "- Cache creation: ${METRIC_CACHE_CREATION}" >> $GITHUB_STEP_SUMMARY
          echo "- Model: ${METRIC_MODEL}" >> $GITHUB_STEP_SUMMARY
